{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog12/08/cs/infinite-type/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>Infinite type sounds not good since we have no idea how much space would it take. Consider this:</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token constant\">Prelude</span><span class=\"token operator\">></span> <span class=\"token keyword\">let</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token constant\">Prelude</span><span class=\"token operator\">></span> <span class=\"token keyword\">let</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token operator\">&lt;</span><span class=\"token hvariable\">interactive</span><span class=\"token operator\">>:</span><span class=\"token number\">2</span><span class=\"token operator\">:</span><span class=\"token number\">9</span><span class=\"token operator\">:</span> <span class=\"token builtin\">error</span><span class=\"token operator\">:</span>\n    • <span class=\"token constant\">Occurs</span> <span class=\"token hvariable\">check</span><span class=\"token operator\">:</span> <span class=\"token hvariable\">cannot</span> <span class=\"token hvariable\">construct</span> <span class=\"token hvariable\">the</span> <span class=\"token hvariable\">infinite</span> <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">~</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span>\n    • <span class=\"token constant\">In</span> <span class=\"token hvariable\">the</span> <span class=\"token hvariable\">expression</span><span class=\"token operator\">:</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span>\n      <span class=\"token constant\">In</span> <span class=\"token hvariable\">an</span> <span class=\"token hvariable\">equation</span> <span class=\"token hvariable\">for</span> ‘<span class=\"token hvariable\">x</span>’<span class=\"token operator\">:</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span>\n    • <span class=\"token constant\">Relevant</span> <span class=\"token hvariable\">bindings</span> <span class=\"token hvariable\">include</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">bound</span> <span class=\"token hvariable\">at</span> <span class=\"token operator\">&lt;</span><span class=\"token hvariable\">interactive</span><span class=\"token operator\">>:</span><span class=\"token number\">2</span><span class=\"token operator\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>At here, the type of <code class=\"language-text\">x</code> was <code class=\"language-text\">Maybe a</code> after the first command; into the second command, it became <code class=\"language-text\">Maybe Maybe Maybe &lt;... infinite Maybe&gt;</code> so we would never know when can we construct the type. So semantic checker or type checker would invent a rule call occurs check. In this case, <code class=\"language-text\">x</code> has a type <code class=\"language-text\">Maybe a</code> at the first step, into the second step it tries to construct a new type <code class=\"language-text\">Maybe Maybe a</code> and unify <code class=\"language-text\">Maybe a</code> with <code class=\"language-text\">Maybe Maybe a</code>, that means found an infinite type definition and it would reject such program.</p>\n<p>But thought again, do we really didn't want infinite type? Or we are only didn't want the infinite construction? I thought the answer is we are trying to prevent infinite construction which we have no idea how big it's.</p>\n<p>So let's dig into mud with curiosity, consider the following program(syntax is pesudo language):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Option[T]\n// &lt;: represents inherit/subtype\n// and I&#39;m comment\nclass Some[T](value: T) &lt;: Option[T]\n// ? explicit tell compiler it&#39;s a fresh free variable type\nclass None &lt;: Option[?]</code></pre></div>\n<p>We can to pattern matching for everytime we want to do operations on <code class=\"language-text\">Option[T]</code>, like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foo(x: Option[int], y: Option[int]): Option[int] {\n  match (x, y) {\n    (Some(lv), Some(rv)) =&gt; return Some(lv + rv)\n    _ =&gt; return None\n  }\n}</code></pre></div>\n<p>It's really annoying and makes us upset. So we invent infinite definition. Wait! You say we cannot measure how big the infinite type was! Yes, but what we are going to do is have an infinite definition for any construction, but we still only allow the finite construction.</p>\n<p>I know that's confusing, so we start a trivial example, at the previous example we have to repackage the result of the operation back into <code class=\"language-text\">Option[T]</code>, we want to directly do operations on <code class=\"language-text\">Option[T]</code>, first take a look at the abstraction of additional:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// +(int, int): int means int implements trait Add\ntrait Add {\n  +(self, self): self;\n}\nclass int &lt;: Add {\n  +(int, int): int;\n}</code></pre></div>\n<p>To make <code class=\"language-text\">Option[T] + Option[T]</code> be possible, we need to make <code class=\"language-text\">Option[T]</code> implements <code class=\"language-text\">Add</code>, so first is we need the ability to reimplement a more special version than <code class=\"language-text\">Option[T]</code> for <code class=\"language-text\">Add</code>, this is because we don't want to change <code class=\"language-text\">Option[T]</code> definition all the time, and this is extendable by users' <code class=\"language-text\">trait</code>. And a more important reason is if <code class=\"language-text\">T</code> is not a subtype of <code class=\"language-text\">Add</code>, which means it's not addable, <code class=\"language-text\">Option[T]</code> should not be able addable either. So consider this definition:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Option[T &lt;: Add] &lt;: Add {\n  +(x: Option[T], y: Option[T]): Option[T] {\n    match (x, y) {\n      (Some(lv), Some(rv)) =&gt; return Some(lv + rv)\n      None =&gt; None\n    }\n  }\n}</code></pre></div>\n<p>Notice why I say it's an infinite definition, this definition says <code class=\"language-text\">Option[T]</code> is a subtype of <code class=\"language-text\">Add</code> and only if <code class=\"language-text\">T</code> is a subtype of <code class=\"language-text\">Add</code>. Then consider this: <code class=\"language-text\">Option[Option[Option[T &lt;: Add]]]</code>, it this type is a subtype of <code class=\"language-text\">Add</code>?</p>\n<ol>\n<li><code class=\"language-text\">T</code> is a subtype of <code class=\"language-text\">Add</code></li>\n<li><code class=\"language-text\">Option[T]</code> is a subtype of <code class=\"language-text\">Add</code> because <code class=\"language-text\">T</code> is a subtype of <code class=\"language-text\">Add</code></li>\n<li>replace <code class=\"language-text\">Option[T]</code> with <code class=\"language-text\">T2</code> and back to step 1</li>\n</ol>\n<p>Now we know, for any <code class=\"language-text\">Option[Option[...]]</code> type, if final <code class=\"language-text\">T</code> is a subtype of <code class=\"language-text\">Add</code>, it's a subtype of <code class=\"language-text\">Add</code>, and we can do the add-operation on it. So whatever user constructs how many of <code class=\"language-text\">Option</code>, we can use the same definition.</p>\n<p>Of course, adding such a feature would be hard, where can we extend a type definition? How can we make sure users use it correctly? How to handle semantic conflict(e.g. several type-extend definitions implement the same <code class=\"language-text\">trait</code>)? But I still thought it's quite interesting and worth to write something about this. Thanks for the read.</p>","frontmatter":{"title":"Infinite Type","categories":["cs"],"tags":["plt","language"]}}},"pageContext":{"slug":"/blog12/08/cs/infinite-type/"}}}