{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogkubernetes/start/from/pod//cs/kubernetes-start-from-pod/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<blockquote>\n<p>欲閱讀本篇文章至少需要知道何為 container，由於範例將採用 Docker 為例，所以也預設讀者已經具備操作 Docker 的能力；且讀過 kubernetes 的<a href=\"https://kubernetes.io/docs/concepts/\">基礎概念</a>只是還沒開始用而已</p>\n</blockquote>\n<p>Kubernetes 最小部署的單位為 Pod，一個 Pod 是 1 至 N 個 container 的群組，它們共享了網路(Network)和儲存空間(Storage)</p>\n<p>這麼設計的好處之一是某些本來就耦合的比較嚴重的元件可以被封裝起來，而不需要硬是重寫成一個元件</p>\n<p>雖然 Pod 是一組 container，對外部而言，那裡只有 Pod 而已，而通常我們還會再用 Service(Kubernetes 的另一種 Resource)包裝一群 Pod</p>\n<blockquote>\n<p>比起是誰在服務，更重要的是有沒有服務</p>\n</blockquote>\n<p>Pod 在 Kubernetes 中會被配給一個邏輯 IP(值得注意的是，這個 IP 是跨 namespace 的)，這即是其他內部(Kubernetes cluster 內)元件連結該 Pod 的通道</p>\n<p>不過在其他東西之前，我想先提有哪些工具可以用來 debug 一個 Pod</p>\n<blockquote>\n<p>p.s. 在接下來的指令中，我都會直接用 <code class=\"language-text\">k</code> 替代 <code class=\"language-text\">kubectl</code>(想知道怎弄就去 google)，<code class=\"language-text\">$</code> 的變數開頭表示是你要按情況修改的參數</p>\n</blockquote>\n<p>Auto completion 的一些討論: <a href=\"https://discuss.kubernetes.io/t/kubectl-tips-and-tricks/192/10\">https://discuss.kubernetes.io/t/kubectl-tips-and-tricks/192/10</a></p>\n<ul>\n<li><code class=\"language-text\">k get po</code>: 這是列出 pods 的意思\n注意是一個 namespace(預設是 deault 這個 namespace)底下的所有，但反正現在講這個就扯太遠，有興趣請參考 <a href=\"https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\">Namespace Doc</a></li>\n<li>\n<p><code class=\"language-text\">k logs $pod-name</code>: 要用這個指令之前你通常會需要上一個指令，因為 <code class=\"language-text\">logs</code> 吃的參數是 Pod 的名稱\ne.g.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ k get po\nNAME                                          READY   STATUS    RESTARTS   AGE\nacs-helloworld-callous-worm-7d549b8f9-dfbhx   <span class=\"token number\">1</span>/1     Running   <span class=\"token number\">0</span>          6h\n$ k logs acs-helloworld-callous-worm-7d549b8f9-dfbhx</code></pre></div>\n<p>這裡 Pod 名字就是 <code class=\"language-text\">acs-helloworld-callous-worm-7d549b8f9-dfbhx</code><br>\n這個指令可以拿到 Pod 中的 container 的 stdout 的輸出(所以我們這裡沒打 container 名稱是因為只有一個 container 存在)，\n你能用 <code class=\"language-text\">-c</code> 或 <code class=\"language-text\">--container</code> 指定特定的 container\np.s. 等等我們建立 Pod 的時候會需要給 Pod 一個名字，那麼你可能會很好奇，為什麼這樣還需要指令？\n這是因為通常我們不會直接建立一個 Pod，而是用 Deployment 一次部署大量的 Pod，這時候產出的名字就跟你眼前所見的差不多糟糕</p>\n</li>\n<li><code class=\"language-text\">k describe po $pod-name</code>: 這個指令非常的重要，因為如果 Pod 根本無法啟動的話，你是拿不到 logs 的，這時候你就只能依靠 describe 取得 kubernetes 知道的訊息，這在環境出問題時可以幫助你更快的定位原因，例如 Node 沒資源給你了</li>\n<li><code class=\"language-text\">k port-forward $pod-name $localhost-port:$pod-port</code>: 這可以把 Pod 的 <code class=\"language-text\">$pod-port</code> 對應到 localhost 的 <code class=\"language-text\">$localhost-port</code> 上，很適合在確定 Pod 如預期般工作時使用</li>\n<li><code class=\"language-text\">k exec -ti $pod-name $command</code>: 這跟 Docker 的 exec 基本一樣，<code class=\"language-text\">$command</code> 用 <code class=\"language-text\">sh</code> 之類的就能進入 container 去做別的事</li>\n</ul>\n<p>那麼，讓我們開始寫第一個 Pod 吧</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># alpine.yaml</span>\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> debugger\n  <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> default\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> alpine\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> alpine\n      <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"sh\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"echo The debugger is running &amp;&amp; sleep 3600\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key atrule\">restartPolicy</span><span class=\"token punctuation\">:</span> Always</code></pre></div>\n<p>選擇這個樣板作為開始是因為我經常用這玩意來 debug 跟測試，所以推薦各位建立兩個這樣的 Pod 作為除錯/測試之用</p>\n<p>接著我解釋一下這個設定檔:</p>\n<ul>\n<li><code class=\"language-text\">apiVersion</code>: 這東西，不要懷疑，去看文件學什麼時候用什麼</li>\n<li><code class=\"language-text\">kind</code>: Resource 的種類</li>\n<li><code class=\"language-text\">metadata</code>: Pod 的一些資訊，這個設定檔有寫的是 <code class=\"language-text\">name</code> 跟 <code class=\"language-text\">namespace</code>，<code class=\"language-text\">name</code> 基本就是你 <code class=\"language-text\">get po</code> 看到的名字，<code class=\"language-text\">namespace</code> 則強制了只能部署在哪個 namespace 底下</li>\n<li>\n<p><code class=\"language-text\">spec</code>: 內容</p>\n<ul>\n<li><code class=\"language-text\">containers</code>: container 的列表，如開頭所言，Pod 是一群 container</li>\n<li><code class=\"language-text\">name</code>: container 的名字(多個 container 時可以用上)</li>\n<li><code class=\"language-text\">image</code>: 所使用的 container 映像檔</li>\n<li><code class=\"language-text\">command</code>: 啟動時執行的命令</li>\n<li><code class=\"language-text\">restartPolicy</code>: 設定 kubernetes 該如何決定何時/是否重啟 Pod，這裡是永遠重啟</li>\n</ul>\n</li>\n</ul>\n<p>Pod 可能在以下五種狀態之一，稱之為 Pod lifecycle:</p>\n<ul>\n<li>Pending: 還有 container image 沒建立完成</li>\n<li>Running: 底下還有 container 正在執行</li>\n<li>Succeeded: Pod 中所有的 container 都正確結束，且 Pod 不再重啟</li>\n<li>Failed: 至少一個 container 不正確的結束，且所有 container 都已被終止</li>\n<li>Unknown: 總之，拿不到 Pod 的狀態</li>\n</ul>\n<p>restartPolicy 可以為</p>\n<ul>\n<li>Always(default): 如果執行結束了也要重啟</li>\n<li>OnFailure: 失敗時重啟</li>\n<li>Never: 掛了就不管了</li>\n</ul>\n<p>在 <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#example-states\">Pod lifecycle#example-states</a> 中有更詳盡的舉例可以學習</p>\n<p>現在我們可以使用這個設定檔建立我們的 Pod 了，指令是 <code class=\"language-text\">k apply -f alpine.yaml</code></p>\n<p><code class=\"language-text\">apply -f</code> 會套用你給的設定檔建立 Resource，同時也會檢查該設定檔的錯誤，如有錯誤是不會建立資源的</p>\n<p>接著你應該會看到 <code class=\"language-text\">pod/alpine created</code> 這樣的回應，這就代表我們的 Pod 成功建立了</p>\n<p>然後我們用 <code class=\"language-text\">logs</code> 指令去查看紀錄</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ k logs alpine\nThe debugger is running</code></pre></div>\n<p>你可以看到啟動時要求 container 執行的指令輸出</p>\n<p>那麼這篇就告一段落，關於 Volume，有興趣的朋友可以先看 <a href=\"https://kubernetes.io/docs/concepts/storage/volumes/\">Volumes</a> 這篇官方介紹</p>\n<h3>References:</h3>\n<h4><a href=\"https://www.manning.com/books/kubernetes-in-action\">Kubernetes in Action</a></h4>\n<ul>\n<li>Author: Marko Lukša</li>\n<li>ISBN: 978-1-617-29372-6</li>\n</ul>\n<h4><a href=\"https://kubernetes.io/docs/concepts/workloads/pods/pod/\">Offical Pod Document</a></h4>","frontmatter":{"title":"Kubernetes 從 Pod 開始","categories":["cs"],"tags":["kubernetes"]}}},"pageContext":{"slug":"/blogkubernetes/start/from/pod//cs/kubernetes-start-from-pod/"}}}