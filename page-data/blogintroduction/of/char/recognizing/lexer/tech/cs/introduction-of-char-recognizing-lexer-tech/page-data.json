{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogintroduction/of/char/recognizing/lexer/tech//cs/introduction-of-char-recognizing-lexer-tech/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<blockquote>\n<p>此篇使用 Rust 作為演示實際程式碼的語言</p>\n</blockquote>\n<p>說到 Lexer 技術，大家應該都會想到正規表達式，但是為什麼是正規表達式呢？\n所以我們要介紹整個掃描並辨識字詞的技術與原理</p>\n<p>最簡單的辨識單字技術是大家都能直接想出來的方法，就是 character-by-character 演算法</p>\n<p>其技術原理非常簡潔，如果要辨識<code class=\"language-text\">new</code>，我們會怎麼做呢？</p>\n<script src=\"https://gist.github.com/dannypsnl/53e8b814c7407e8621fbe05d45e7cb67.js\"></script>\n<p>可以看出為什麼每個人都想得出來吧！因為整個 CBC 的邏輯就是完全符合的字串就是我們要的字串</p>\n<p>但是問題來了，如果我們想要辨識<code class=\"language-text\">night</code>怎麼辦呢？每個我們想要的字串都寫一個辨識程式的話，那不是很浪費空間跟時間嗎？\n所以我們需要縮減程式，如何縮減？</p>\n<p>我們可以很輕鬆的發現其實<code class=\"language-text\">new</code>與<code class=\"language-text\">night</code>的第一個字元都是<code class=\"language-text\">n</code>，所以我們可以把程式變成：</p>\n<script src=\"https://gist.github.com/dannypsnl/097fe61c1bbbf7835cbd14336fc66cda.js\"></script>\n<p>這樣的簡化對問題的根源沒有幫助，但是引出了重點，我們可以有多種線路的選擇，那麼能不能讓多種線路移至同樣地狀態呢？\n答案當然是可以的。為了說明清楚我在說什麼，讓我們用圖來描述<code class=\"language-text\">is_new</code>做了什麼：</p>\n<div id=\"state_machine_graphic_of_new\"></div>\n<p><code class=\"language-text\">s0</code>是我們的初始狀態，紅色代表接受狀態，所謂接受狀態你也可以說是辨識成功，一般來說我們會省略錯誤狀態，你只要找不到對應的<code class=\"language-text\">edge</code>我們就會移至錯誤狀態</p>\n<p>那麼我們再看與規則<code class=\"language-text\">night</code>結合後的圖</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   n     e     w\ns0 -&gt; s1 -&gt; s2 -&gt; s3(sª)\n         i     g     h     t\n         -&gt; s4 -&gt; s5 -&gt; s6 -&gt; s7(sª)</code></pre></div>\n<p>所以所謂的多種線路移至同一狀態是什麼意思呢？假設我們要辨識一個英文單字，我們只需要是<code class=\"language-text\">a..z</code>(不管大小寫)都接受，所以圖就是：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   a     a\ns0 -&gt; s1 -&gt; s1 -&gt; ... -&gt; s1\n   b\n   -&gt; s1\n   c\n   -&gt; s1\n   ...\n   ...\n   ...\n   z\n   -&gt; s1</code></pre></div>\n<p>可以發現模式是重複而無限的，所以我們可以簡化成：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  a..z\ns0 -&gt; s1 &lt;--\n      |    | a..z\n       \\__/</code></pre></div>\n<p>ps. 這裡的<code class=\"language-text\">s1</code>是<code class=\"language-text\">sª</code></p>\n<p>那麼這樣的狀態圖要如何實作呢？</p>\n<script src=\"https://gist.github.com/dannypsnl/301605038c23d828acc1447ced5f9cf4.js\"></script>\n<p>就跟圖一樣需要用個迴圈處理重複的工作，當然你也可以用遞迴的方式實作：</p>\n<script src=\"https://gist.github.com/dannypsnl/12fe67d584857d1810f5d460f77d12af.js\"></script>\n<p>看完思想跟實作之後，讓我們深入了解數學定義吧！\n我們稱這種辨識技術為<code class=\"language-text\">有限狀態自動機</code>(<code class=\"language-text\">Finite Automata</code>)，其數學式由五個元組組成。\n分別是：<code class=\"language-text\">S</code>, <code class=\"language-text\">∑</code>, <code class=\"language-text\">∂</code>, <code class=\"language-text\">s0</code>, <code class=\"language-text\">sª</code></p>\n<p><code class=\"language-text\">S</code>代表所有狀態的集合(包含錯誤狀態)，<code class=\"language-text\">∑</code>代表所有邊界標籤的聯集，<code class=\"language-text\">∂</code>代表所有轉換函數的集合，<code class=\"language-text\">s0</code>是初始狀態，<code class=\"language-text\">sª</code>是接受狀態</p>\n<p>以一開始的<code class=\"language-text\">new</code>為例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">S = {s0, s1, s2, s3, se}\n∑ = {n, e, w}\n∂ = {\n     n\n  s0 -&gt; s1,\n     e\n  s1 -&gt; s2,\n     w\n  s2 -&gt; s3,\n}\ns0 = s0\nSª = {s3}</code></pre></div>\n<p>很明顯的，FA 的表示法非常麻煩，那麼就回到大家熟悉的正規表達式了。\n我不贅述怎麼寫正規表達式，有很多專門介紹正規表達式的文章了</p>\n<p>以<code class=\"language-text\">Antlr</code>的<code class=\"language-text\">new</code>為例：</p>\n<div class=\"gatsby-highlight\" data-language=\"antlr4\"><pre class=\"language-antlr4\"><code class=\"language-antlr4\"><span class=\"token definition token constant\">NEW</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">&#39;</code>中就是正規表達式了</p>\n<p>像上面辨識單字的程式可以表示成</p>\n<div class=\"gatsby-highlight\" data-language=\"antlr4\"><pre class=\"language-antlr4\"><code class=\"language-antlr4\"><span class=\"token definition token constant\">WORD</span><span class=\"token punctuation\">:</span> <span class=\"token character-class regex\"><span class=\"token punctuation\">[</span>a<span class=\"token range punctuation\">-</span>zA<span class=\"token range punctuation\">-</span>Z<span class=\"token punctuation\">]</span></span><span class=\"token operator\">+</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">[]</code>中是字元集，<code class=\"language-text\">+</code>表示至少 match 一個</p>\n<p>關於 Lexer，可以算是告一段落，哪天應該會寫一下 Parser 那的技術</p>\n<p>總結一下，我們今天學到的是狀態機的概念與各種常見實作，如果真的弄懂的話，手刻一個自己的 Lexer 應該不是難事，如果有任何疑難都可以在下面留言，我會盡力回答</p>\n<h3>References:</h3>\n<h4><a href=\"https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0\">Engineering a compiler</a></h4>\n<ul>\n<li>Author: Keith D. Cooper &#x26; Linda Torczon</li>\n<li>ISBN: 978-0-12-088478-0</li>\n</ul>\n<h4><a href=\"http://shop.oreilly.com/product/0636920040385.do\">Programming Rust</a></h4>\n<ul>\n<li>Author: Jim Blandy &#x26; Jason Orendorff</li>\n<li>ISBN: 978-1-491-92728-1</li>\n</ul>\n<h4><a href=\"https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811\">Compilers: principles, techniques, and tools: 2E</a></h4>\n<ul>\n<li>Author: Alfred V. Aho &#x26; Monica S. Lam &#x26; Ravi Sethi &#x26; Jeffrey D. Ullman</li>\n<li>ISBN: 978-986-154-936-1(Traditional Chinese Version)</li>\n</ul>\n<script>\n\nd3.select(\"#state_machine_graphic_of_new\")\n  .style(\"background-color\", \"#e8e8e8\")\n  .style(\"font-size\", \"18px\")\n  .append(\"svg\")\nvar svg = d3.select(\"#state_machine_graphic_of_new > svg\");\nfunction newline(svg, x1, y1, x2, y2) {\n  svg\n  .append(\"line\")\n  .attr(\"x1\", x1)\n  .attr(\"y1\", y1)\n  .attr(\"x2\", x2)\n  .attr(\"y2\", y2)\n  .style(\"stroke\", \"black\")\n  .style(\"stroke-width\", \"2px\")\n}\nfunction newcircle(svg, r, x, y, color) {\n  svg.append(\"circle\")\n    .attr(\"r\", r)\n    .attr(\"cx\", x)\n    .attr(\"cy\", y)\n    .style(\"fill\", color)\n}\nfunction newtext(svg, x, y, text) {\n  svg.append(\"text\")\n    .attr(\"x\", x)\n    .attr(\"y\", y)\n    .text(text)\n}\n\nnewtext(svg, 53, 70, \"n\")\nnewline(svg, 30, 80, 90, 80)\n\nnewtext(svg, 115, 70, \"e\")\nnewline(svg, 90, 80, 150, 80)\n\nnewtext(svg, 175, 70, \"w\")\nnewline(svg, 150, 80, 210, 80)\n\nnewcircle(svg, 20, 30, 80, \"gray\")\nnewtext(svg, 18, 88, \"s0\")\n\nnewcircle(svg, 20, 90, 80, \"gray\")\nnewtext(svg, 80, 88, \"s1\")\n\nnewcircle(svg, 20, 150, 80, \"gray\")\nnewtext(svg, 140, 88, \"s2\")\n\nnewcircle(svg, 20, 210, 80, \"red\")\nnewtext(svg, 199, 88, \"s3\")\n</script>","frontmatter":{"title":"Introduction Of Char Recognizing -- Lexer Tech","categories":["cs"],"tags":["compiler","lexer","rust"]}}},"pageContext":{"slug":"/blogintroduction/of/char/recognizing/lexer/tech//cs/introduction-of-char-recognizing-lexer-tech/"}}}