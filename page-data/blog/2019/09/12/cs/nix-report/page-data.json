{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2019/09/12/cs/nix-report/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>This article is created as a record of the feedback of the usage of nix, also stand for learning how to use nix in daily developing life. Remember I would not dig into the implementation or model concept inside of nix but all about how to use it to improve the developing environment.</p>\n<h3>Install</h3>\n<p>To install nix all you have to do is running: <code class=\"language-text\">sh &lt;(curl https://nixos.org/nix/install) --no-daemon</code> and follow the content, provided by the script after the script installed process down, on Linux or macOS.</p>\n<p>To avoid outdated information, here is the <a href=\"https://nixos.org/nix/manual/#sect-single-user-installation\">single-user installation</a>(which you do above), and the <a href=\"https://nixos.org/nix/manual/#sect-multi-user-installation\">multi-user installation</a>.</p>\n<h3>Introduction</h3>\n<p>After installation, you would get several different commands for different purposes. I would introduce them one by one(only for those I'm using).</p>\n<h4>nix-env</h4>\n<p><code class=\"language-text\">nix-env</code> is like <code class=\"language-text\">brew</code> for MacOS, <code class=\"language-text\">apt-get</code> for Ubuntu, <code class=\"language-text\">yum</code> for CentOS, but for all platform with nix. This command is the first one command would help immediately. You can do: <code class=\"language-text\">nix-env -i go</code> or <code class=\"language-text\">nix-env --install go</code>, after that let's check the binary <code class=\"language-text\">go</code> by <code class=\"language-text\">which go</code>, is located at <code class=\"language-text\">$HOME/.nix-profile/bin/go</code>. You can also use different channel(package source) for self-deployed packages or any other is not provided by nix channel.</p>\n<p>Use <code class=\"language-text\">nix-env --help</code> to get more information</p>\n<h4>nix-shell</h4>\n<p><code class=\"language-text\">nix-shell</code> would read <code class=\"language-text\">shell.nix</code> or fallback to read <code class=\"language-text\">default.nix</code> these config files. To understand what we do in it we need an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"nix\"><pre class=\"language-nix\"><code class=\"language-nix\"><span class=\"token keyword\">let</span>\n  pkgs <span class=\"token operator\">=</span> <span class=\"token function\">import</span> <span class=\"token operator\">&lt;</span>nixpkgs<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">inherit</span> <span class=\"token punctuation\">(</span>pkgs<span class=\"token punctuation\">)</span> mkShell<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">inherit</span> <span class=\"token punctuation\">(</span>pkgs<span class=\"token punctuation\">)</span> haskellPackages<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">inherit</span> <span class=\"token punctuation\">(</span>haskellPackages<span class=\"token punctuation\">)</span> cabal<span class=\"token operator\">-</span>install<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">inherit</span> <span class=\"token punctuation\">(</span>haskellPackages<span class=\"token punctuation\">)</span> stylish<span class=\"token operator\">-</span>haskell<span class=\"token punctuation\">;</span>\n\n  ghc <span class=\"token operator\">=</span> haskellPackages<span class=\"token punctuation\">.</span>ghcWithPackages <span class=\"token punctuation\">(</span>pkgs<span class=\"token punctuation\">:</span> <span class=\"token keyword\">with</span> pkgs<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">[</span>base mtl<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">in</span>\nmkShell <span class=\"token punctuation\">{</span>\n  buildInputs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    ghc\n    cabal<span class=\"token operator\">-</span>install\n    stylish<span class=\"token operator\">-</span>haskell\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">mkShell</code> would return a shell by its argument set: <code class=\"language-text\">{}</code>, at here we can take a look at <code class=\"language-text\">stylish-haskell</code> this Haskell formatter, in <code class=\"language-text\">nix-shell</code> environment type <code class=\"language-text\">which stylish-haskell</code> would get <code class=\"language-text\">/nix/store/qqj9ldclapfbxhnvb357mjy5d5rjg6ip-stylish-haskell-0.9.2.2/bin/stylish-haskell</code>, and if you quit the environment should won't have the binary.</p>\n<h4>nix-build</h4>\n<p>Now, we already introduce the global level installer and project level installer. We have to go into how to create your own package.</p>\n<p><code class=\"language-text\">nix-build</code> would read <code class=\"language-text\">default.nix</code> to use its value as your package. Let's take a look at what it means.</p>\n<div class=\"gatsby-highlight\" data-language=\"nix\"><pre class=\"language-nix\"><code class=\"language-nix\"><span class=\"token keyword\">let</span>\n  pkgs <span class=\"token operator\">=</span> <span class=\"token function\">import</span> <span class=\"token operator\">&lt;</span>nixpkgs<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  dependencies <span class=\"token operator\">=</span> <span class=\"token function\">import</span> <span class=\"token url\">./deps.nix</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">in</span>\n  pkgs<span class=\"token punctuation\">.</span>haskellPackages<span class=\"token punctuation\">.</span>callPackage <span class=\"token url\">./little-scheme.nix</span> <span class=\"token punctuation\">{</span> dependencies<span class=\"token operator\">=</span>dependencies<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ignore <code class=\"language-text\">deps.nix</code>, that's a list has all Haskell dependencies I used.</p>\n<p><code class=\"language-text\">pkgs.haskellPackages.callPackage</code> creates a haskell package via it's argument. Let's dig into what <code class=\"language-text\">little-scheme.nix</code> do:</p>\n<div class=\"gatsby-highlight\" data-language=\"nix\"><pre class=\"language-nix\"><code class=\"language-nix\"><span class=\"token punctuation\">{</span> mkDerivation<span class=\"token punctuation\">,</span> base<span class=\"token punctuation\">,</span> mtl<span class=\"token punctuation\">,</span> dependencies<span class=\"token punctuation\">,</span> stdenv <span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span>\nmkDerivation <span class=\"token punctuation\">{</span>\n  pname <span class=\"token operator\">=</span> <span class=\"token string\">\"little-scheme\"</span><span class=\"token punctuation\">;</span>\n  version <span class=\"token operator\">=</span> <span class=\"token string\">\"0.1.0\"</span><span class=\"token punctuation\">;</span>\n  src <span class=\"token operator\">=</span> stdenv<span class=\"token punctuation\">.</span>lib<span class=\"token punctuation\">.</span>sourceFilesBySuffices <span class=\"token url\">./.</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\".hs\"</span> <span class=\"token string\">\".cabal\"</span> <span class=\"token string\">\"LICENSE\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  isLibrary <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  isExecutable <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  executableHaskellDepends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span> base mtl <span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span> dependencies<span class=\"token punctuation\">;</span>\n  license <span class=\"token operator\">=</span> stdenv<span class=\"token punctuation\">.</span>lib<span class=\"token punctuation\">.</span>licenses<span class=\"token punctuation\">.</span>mit<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">src</code> be set to <code class=\"language-text\">stdenv.lib.sourceFilesBySuffices ./. [&quot;.hs&quot; &quot;.cabal&quot; &quot;LICENSE&quot;]</code>, this line means only <code class=\"language-text\">.hs</code>, <code class=\"language-text\">.cabal</code> and <code class=\"language-text\">LICENSE</code> would lead a new build.</p>\n<p><code class=\"language-text\">executableHaskellDepends</code> would take a list of Haskell libraries.</p>\n<p><code class=\"language-text\">{}: expression</code> is a function. <code class=\"language-text\">{}</code> use pattern matching to extract the value from input set. <code class=\"language-text\">a: c</code> is take <code class=\"language-text\">a</code> return <code class=\"language-text\">c</code>, <code class=\"language-text\">a: b: c</code> is take <code class=\"language-text\">a</code> return <code class=\"language-text\">b: c</code>, consider to read <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">lambda calculus</a> to understand the function in nix.</p>\n<h3>Advanced use case</h3>\n<h4>direnv</h4>\n<p><code class=\"language-text\">direnv</code> is a powerful shell environment extension, it loads or unloads an environment depending on the current directory. To install it we can execute <code class=\"language-text\">nix-env --install direnv</code>, then add <code class=\"language-text\">eval &quot;$(direnv hook zsh)&quot;</code> at the end of <code class=\"language-text\">$HOME/.zshrc</code>(<a href=\"https://github.com/direnv/direnv/blob/master/docs/hook.md\">for others shells</a>).</p>\n<p><code class=\"language-text\">direnv</code> supports using nix as environment configuration, you can put <code class=\"language-text\">use_nix</code> in the <code class=\"language-text\">$dir/.envrc</code>, and it would watch <code class=\"language-text\">$dir/shell.nix</code> and <code class=\"language-text\">$dir/default.nix</code> to update the environment. However, the current version <code class=\"language-text\">use_nix</code> has cache missing issue, so you can just copy whole content from <a href=\"https://github.com/kalbasit/nur-packages/blob/master/pkgs/nixify/envrc\">https://github.com/kalbasit/nur-packages/blob/master/pkgs/nixify/envrc</a>, and put <code class=\"language-text\">use_nix -s shell.nix</code> in the <code class=\"language-text\">$dir/.envrc</code>.</p>\n<p>p.s. A minor issue is <code class=\"language-text\">direnv</code> do not work with <code class=\"language-text\">alias</code>, so probably still have to use <code class=\"language-text\">$HOME/.zshrc</code> to manage them.</p>","frontmatter":{"title":"nix report","categories":["cs"],"tags":["nix","shell"]}}},"pageContext":{"slug":"/blog/2019/09/12/cs/nix-report/"}}}