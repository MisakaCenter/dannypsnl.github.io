{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2019/12/13/cs/from-infinite-type-to-functor/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>At <a href=\"/blog/2019/12/08/cs/infinite-type/\">infinite type</a> I mention a way(recursive abstract data type) to make we use <code class=\"language-text\">Option[T]</code> just like <code class=\"language-text\">T</code>. However, such modeling is not enough. Consider the following example(with the same pseudo syntax takes from <a href=\"/blog/2019/12/08/cs/infinite-type/\">infinite type</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Foo {\n  bar(): Bar;\n}</code></pre></div>\n<p>Now we want to use <code class=\"language-text\">Option[Foo]</code> as <code class=\"language-text\">Foo</code>. In a normal use case, we have:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foo: Foo = Foo();\nbar: Bar = foo.bar();</code></pre></div>\n<p>Once we put <code class=\"language-text\">Foo</code> into the box, it became:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foo: Option[Foo] = Some(Foo());\n// we say use Option[Foo] as Foo, so foo.bar should be supported just like it&#39;s existed under Option[Foo]\nbar: Bar = foo.bar();</code></pre></div>\n<p>It seems easy at first look, but consider this case:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foo: Option[Foo] = None;\nbar: Bar = foo.bar();</code></pre></div>\n<p>What should we do? Terminate program is definitely not what we want, our purpose is reducing the unneeded check(let's say before we surely use the data to show something to UI is not need to check), not create a fragile software. And if we want <code class=\"language-text\">foo.bar()</code> crash the program at here we even don't have to model <code class=\"language-text\">Option</code>, just introduce bottom type just like the language that allows null object. So what is our purpose? Is to make <code class=\"language-text\">foo.bar()</code> automatically returns <code class=\"language-text\">Option[Bar]</code>.</p>\n<p>Now, let's think about how to make it. Consider this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Foo {\n  bar(): Bar;\n}\nclass Option[Foo] &lt;: Foo {\n  bar(): Bar {\n    // implementation\n  }\n}</code></pre></div>\n<p>This model is bad, first, it cannot let <code class=\"language-text\">Bar</code> became <code class=\"language-text\">Option[Bar]</code>; second, it causes an interesting problem: <code class=\"language-text\">Option[Foo]</code> is a subtype of <code class=\"language-text\">Foo</code> which means the following code is valid:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foo: Foo = Some(Foo());</code></pre></div>\n<p>However, how do we sure <code class=\"language-text\">Foo</code> is <code class=\"language-text\">Option[Foo]</code> or <code class=\"language-text\">Foo</code> now? In fact, now we make an infinite definition of the type which has a size(such type takes real memory to store), which means we cannot make this kind of type. This is the reason why we have a function called <code class=\"language-text\">fmap</code> in <strong>Haskell</strong>!</p>\n<p>Take a look at the type of <code class=\"language-text\">fmap</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">fb</span></code></pre></div>\n<p>For the <code class=\"language-text\">Maybe</code> type, we create:</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- We can do nothing with Nothing</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code></pre></div>\n<p>For List: <code class=\"language-text\">[a]</code> we create:</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">-- yep, for list, fmap is map</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span></code></pre></div>\n<p>Ok, so we create such a program for all the box type(such type provide common wrapping for others type)? No!</p>\n<p>In <strong>Haskell</strong>, it actually defines a <code class=\"language-text\">class</code>(<strong>Haskell</strong> <code class=\"language-text\">class</code> is very different with <strong>Java</strong> one) for this situation, called <code class=\"language-text\">Functor</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span>\n\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">where</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span>\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Maybe</span> <span class=\"token keyword\">where</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code></pre></div>\n<p>We also can create <code class=\"language-text\">instance Functor (a, b)</code>, like:</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token comment\">-- `(,) a b` is `(a, b)`, you can find Haskell treats binary operator as a function takes two parameters everywhere(if I'm wrong, tell me)</span>\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- (2, 6)</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- (3, 6)</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- (3, 7)</span></code></pre></div>\n<p>In this case, <code class=\"language-text\">f a</code> &#x3C;=> <code class=\"language-text\">f</code> is <code class=\"language-text\">(,) a</code>, <code class=\"language-text\">a</code> is <code class=\"language-text\">b</code>.</p>\n<p>Now, let's make a mind blow up. I say that binary operator in <strong>Haskell</strong> is all modeling like a function, so <code class=\"language-text\">a -&gt; b</code> is <code class=\"language-text\">(-&gt;) a b</code>, in fact, I thought people who familiar with <strong>Lisp</strong> would not feel it weird.</p>\n<p>According to <code class=\"language-text\">(a -&gt; b) -&gt; f a -&gt; f b</code>, first, to make symbol would not conflict, we use: <code class=\"language-text\">(b -&gt; c) -&gt; f b -&gt; f c</code>. Then use <code class=\"language-text\">(-&gt;) a</code> to replace <code class=\"language-text\">f</code>: <code class=\"language-text\">(b -&gt; c) -&gt; ((-&gt;) a b) -&gt; ((-&gt;) a c)</code>, then normalize it: <code class=\"language-text\">(b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>. Those knows <strong>Haskell</strong> now should jump and say: Compose! Yes, let's see the definition:</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">fa</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">fa</span></code></pre></div>\n<p>I hope you have enough fun with <strong>Functor</strong> X).</p>\n<p>Let's back to the problem: How to use <code class=\"language-text\">Option[Foo]</code> as <code class=\"language-text\">Foo</code>?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">trait Functor[a] {\n  // let&#39;s assuming we have a syntax like this which would require `self` is a type that takes one type parameter and export the type binding to `f` and `a`(and `a` would cause a unification here, since `Functor` have one also, so `a` already bound, `self` has to satisfy it).\n  f[a] = self;\n  fmap[b](self, (a): b): f[b];\n}\n\nclass Option[T] &lt;: Functor[T] {\n  fmap[b](self: Option[T], func: (T): b): Option[b] {\n    match self {\n      Some(v) =&gt; {\n        return func(v);\n      }\n      None =&gt; {\n        return None;\n      }\n    }\n  }\n}</code></pre></div>\n<p>To use it, we cannot keep the totally same code anymore:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foo: Option[Foo] = Some(Foo());\nbar: Option[Bar] = foo.fmap[Bar](foo.bar);</code></pre></div>\n<p>Now we make an object-syntax-oriented version's <strong>Functor</strong>. You can see the definition is a little bit... ok, very hard to read. But if we really want such extendability(unify box types), then probably is worth it. I haven't mentioned category theory, <strong>Applicative</strong>(finally!) and other things in <strong>Haskell</strong> or other languages. Hopefully, I can complete them in the future, and in the end thanks for your read.</p>","frontmatter":{"title":"From Infinite Type to Functor","categories":["cs"],"tags":["plt","functor","language","haskell"]}}},"pageContext":{"slug":"/blog/2019/12/13/cs/from-infinite-type-to-functor/"}}}