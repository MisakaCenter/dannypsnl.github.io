{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2017/07/08/cs/lexer-explains/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>因為 Elz 實在是一個遠超我一開始的預想的語言(最開始只是想了解編譯器，乾脆就開始設計新語言了)</p>\n<p>打造花了我很多心思，Elz 採用先從原始碼中取得詞素，再分析詞素的設計</p>\n<p>這樣一來兩邊都可以降低實作的複雜度</p>\n<p>分成<code class=\"language-text\">lexer</code>與<code class=\"language-text\">parser</code>兩大主軸工作之後，考慮到效能，我沒有採用 lex 這種吸引人的作法(其實一開始是有試過，最重要的問題是我覺得學那個好麻煩 XD)</p>\n<p>而是手刻這個部分，其中最重要的設計就是利用<code class=\"language-text\">Golang</code>的共時技巧，讓<code class=\"language-text\">parser</code>可以不用等待<code class=\"language-text\">lexer</code>的完成</p>\n<p>這個技術的完成第一是寫出一個函數，建立一個<code class=\"language-text\">lexer</code>實體，接著用<code class=\"language-text\">goroutine</code>啟動<code class=\"language-text\">(*lexer) run()</code>這個函數，最後這個函數回傳這個<code class=\"language-text\">lexer</code>實體</p>\n<p>run 之中放著 State Function 迴圈</p>\n<p>什麼是 State Function? 它就是一個型別函數，不過它所指的函數回傳自己這個型別以作為狀態變遷的依據</p>\n<p><code class=\"language-text\">stateFn</code>定義如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> stateFn <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Lexer<span class=\"token punctuation\">)</span> stateFn</code></pre></div>\n<p>什麼叫狀態變遷? 這樣有什麼好處?</p>\n<p>讓我們回顧 Lexer 的原理，它接收一個字元串流，根據讀到的字元進行不同的操作，以得到詞素串流</p>\n<p>所以不同的字元就是那個狀態啦!</p>\n<p>而傳統的做法都像下面那樣</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">LexAll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> number<span class=\"token operator\">:</span>\n    <span class=\"token function\">LexNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">case</span> alphabra<span class=\"token operator\">:</span>\n    <span class=\"token function\">LexIdentifier</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>重複不斷的程式碼，而且我們一直在呼叫函數</p>\n<p>那何不傳回我們想執行的下一個函式?</p>\n<p>這就是 State Function 所想要表達的意思</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">lexWhiteSpace</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">*</span>Lexer<span class=\"token punctuation\">)</span> stateFn <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> r <span class=\"token operator\">:=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token function\">isSpace</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> r<span class=\"token operator\">==</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        r <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    l<span class=\"token punctuation\">.</span><span class=\"token function\">backup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// break mount's rune is not a space</span>\n    l<span class=\"token punctuation\">.</span><span class=\"token function\">ignore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// because no emit, we need ignore will mount's pos runes</span>\n\n    <span class=\"token keyword\">switch</span> r <span class=\"token operator\">:=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> r <span class=\"token operator\">==</span> EOF<span class=\"token punctuation\">:</span>\n        l<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>ItemEOF<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token keyword\">case</span> r <span class=\"token operator\">==</span> <span class=\"token string\">'='</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> lexEqualOp <span class=\"token comment\">// =, ==</span>\n    <span class=\"token keyword\">case</span> r <span class=\"token operator\">==</span> <span class=\"token string\">':'</span><span class=\"token punctuation\">:</span>\n        l<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>ItemColon<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> lexWhiteSpace\n    <span class=\"token keyword\">case</span> r <span class=\"token operator\">==</span> <span class=\"token string\">'\"'</span> <span class=\"token operator\">||</span> r <span class=\"token operator\">==</span> <span class=\"token string\">'`'</span> <span class=\"token operator\">||</span> r <span class=\"token operator\">==</span> <span class=\"token string\">'\\''</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> lexString <span class=\"token comment\">// \"string literal\", `string literal`</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'0'</span> <span class=\"token operator\">&lt;=</span> r <span class=\"token operator\">&amp;&amp;</span> r <span class=\"token operator\">&lt;=</span> <span class=\"token string\">'9'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> lexNumber <span class=\"token comment\">// 12323, 2.344</span>\n    <span class=\"token keyword\">case</span> <span class=\"token function\">isAlphaNumeric</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> lexIdentifiers <span class=\"token comment\">// car, car_build</span>\n    <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Sprintf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Don't know how to do with: %q\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這是作為初始狀態的狀態函數內部實作(省略沒有辦法幫助你理解它的部分)</p>\n<p>再看<code class=\"language-text\">lexNumber</code></p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">lexNumber</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">*</span>Lexer<span class=\"token punctuation\">)</span> stateFn <span class=\"token punctuation\">{</span>\n    firstDot <span class=\"token operator\">:=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">for</span> r <span class=\"token operator\">:=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">(</span> <span class=\"token string\">'0'</span> <span class=\"token operator\">&lt;=</span> r <span class=\"token operator\">&amp;&amp;</span> r <span class=\"token operator\">&lt;=</span> <span class=\"token string\">'9'</span> <span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> r <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">;</span> r <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> r <span class=\"token operator\">==</span> <span class=\"token string\">'.'</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> firstDot <span class=\"token punctuation\">{</span>\n                firstDot <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">break</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    l<span class=\"token punctuation\">.</span><span class=\"token function\">backup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    l<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>ItemNumber<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> lexWhiteSpace\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>發現了嗎? 只要回傳初始狀態函數</p>\n<p>由於我們不斷執行下一個狀態函數，所以我們就回到初始狀態了，而且不需要初始狀態碼跟初始狀態用的函數兩個東西來完成它</p>\n<p>這時我們就要回到 run 的實現了</p>\n<p>看看它有多麼的簡單</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">*</span>Lexer<span class=\"token punctuation\">)</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> l<span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> lexWhiteSpace<span class=\"token punctuation\">;</span> l<span class=\"token punctuation\">.</span>state <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">{</span>\n        l<span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">state</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n得到一個狀態函數參考，然後執行狀態函數，就這麼簡單\n\n<span class=\"token comment\">// l.state是一個stateFn</span></code></pre></div>\n<p>我改用Ｃ＋＋實作了，不過這篇的技術還是很有趣，所以就留下來吧！</p>\n<p>ps. 2017/12/29. 我現在還是用 Go，只是先用 antlr 產生 parser(開發速度)</p>","frontmatter":{"title":"lexer 原理解釋","categories":["cs"],"tags":["compiler","lexer","golang"]}}},"pageContext":{"slug":"/blog/2017/07/08/cs/lexer-explains/"}}}