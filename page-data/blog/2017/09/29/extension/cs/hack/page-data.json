{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2017/09/29/extension/cs/hack/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>好吧，上一篇說了這麼多，其實幾乎就只是把屬性定義在類別外罷了，沒什麼啊</p>\n<p>這樣並沒有比<code class=\"language-text\">class</code>強到哪裡</p>\n<p>所以，讓我們來看看<code class=\"language-text\">extension hacks</code>吧！</p>\n<h2>hack 1:</h2>\n<blockquote>\n<p>extension from a temporary protocol</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">protocol</span> <span class=\"token builtin\">MenuItem</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">extension</span> label <span class=\"token punctuation\">:</span> <span class=\"token builtin\">MenuItem</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">extension</span> button <span class=\"token punctuation\">:</span> <span class=\"token builtin\">MenuItem</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">MenuItem</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token function\">label</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token function\">button</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Click me\"</span><span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>哇，這下我們可以用<code class=\"language-text\">List&lt;MenuItem&gt;</code>來存放我們所想要存放的型別了，只要將你想要存放的型別<code class=\"language-text\">extension</code>一下<code class=\"language-text\">MenuItem</code>這個協定，就是這麼簡單</p>\n<p>注意這個機制有幾個問題，第一是如果你想要呼叫某個屬於 label 的方法，你將會得到沒有此方法的編譯期錯誤</p>\n<p>那，有辦法解決嗎？</p>\n<p>有！首先我們要知道為什麼會這樣，如果你曾經在<code class=\"language-text\">shell</code>中嘗試過印出<code class=\"language-text\">type(of: xxx)</code></p>\n<p>那麼你一定知道型別後面都接有一個位元組，這個位元組，其實就是實際上型別在執行期的樣子啦！因此在執行期中，為了確保最大的安全度，編譯器常用最小介面原則，選擇概念最寬廣的那個型別</p>\n<p>那麼編譯器要怎麼知道你是要呼叫子型別的方法還是父型別的呢？</p>\n<p>在 C++我們可以用<code class=\"language-text\">-&gt;</code>運算子以及指標，確保我們直接存取實體，而且我們不需要聲明子型別是什麼，因為編譯器有在記</p>\n<p>不過產生的問題就是，有時候你並不知道到底有沒有這個方法(當然，新的 IDE 與工具們提供了這些，但是我們常常還是編譯下去之後才知道)，進而需要搜尋你用了哪個子型別</p>\n<p>而在 Swift，我們用<code class=\"language-text\">(instance as! Type).method()</code>使用子型別的方法，缺點是那個括號跟不甚明瞭的語意，而且我們為了確保安全，還要多做一個\n<code class=\"language-text\">if instacne is Type</code>的檢查</p>\n<p>回到<code class=\"language-text\">Swift</code></p>\n<p>第一種作法是直接在<code class=\"language-text\">MenuItem</code>上定義一個方法作為統一的介面，任何型別擴展<code class=\"language-text\">MenuItem</code>時，就實作該方法</p>\n<p>第二種作法是我們將<code class=\"language-text\">MenuItem</code>轉換成原本的型別</p>\n<p>這種作法有個小問題：</p>\n<p>問題在於，我們知道<code class=\"language-text\">label</code>是一種<code class=\"language-text\">MenuItem</code>，但是你怎麼知道，某個<code class=\"language-text\">MenuItem</code>是<code class=\"language-text\">label</code>?</p>\n<p>所以我們需要對它進行危險的轉換</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token function\">MenuItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span><span class=\"token operator\">!</span> label <span class=\"token comment\">// as! 意思是將左邊的值當成右邊的型別來使用，而且這是危險的</span></code></pre></div>\n<blockquote>\n<p>ps. 這只是示意，不能運作</p>\n</blockquote>\n<p>而這對工作上非常不合用，也很難凸顯我們想要做什麼</p>\n<p>所以我寫了一個轉換函式</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">func</span> convert<span class=\"token operator\">&lt;</span>F<span class=\"token punctuation\">,</span> T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">:</span> F<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> T <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> from <span class=\"token keyword\">is</span> T <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> from <span class=\"token keyword\">as</span><span class=\"token operator\">!</span> T\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> to\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>ps. 請不要真的用這個函數做事，這只是為了先避開複雜議題(例外處理)才這樣寫的</p>\n</blockquote>\n<p>於是我們可以用</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">:</span> <span class=\"token function\">MenuItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">:</span> <span class=\"token function\">label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>取得一個轉換結果，在這裡因為我們失敗時<code class=\"language-text\">(from不是一種T)</code>就回傳<code class=\"language-text\">to</code></p>\n<p>我們沒辦法知道是成功抑或失敗，因此我們應該對此有所區別</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">func</span> downCast<span class=\"token operator\">&lt;</span>F<span class=\"token punctuation\">,</span> T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">:</span> F<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">:</span> T<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> T<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> from <span class=\"token keyword\">is</span> T <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> from <span class=\"token keyword\">as</span><span class=\"token operator\">?</span> T\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token constant\">nil</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這是第二版的轉換函數，我用<code class=\"language-text\">downCast</code>是要說明我們在做危險的向下轉型(上面的<code class=\"language-text\">convert</code>則是說明它是通用的轉換)</p>\n<p>同時這次失敗將回傳<code class=\"language-text\">nil</code></p>\n<p>因此使用上使用者將需要多負擔一個<code class=\"language-text\">!</code>來解包</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token function\">downCast</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">:</span> num<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">:</span> <span class=\"token function\">Double</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>res<span class=\"token operator\">!</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>藉由<code class=\"language-text\">nil</code>，這個版本保證我們通常能知道有沒有轉型失敗(不過回傳<code class=\"language-text\">nil</code>雖然侵入性小，卻也把檢查責任丟給客戶端，而且不能應付本來就是<code class=\"language-text\">nil</code>的實體)</p>\n<p>同時，我認為大部分時候，我們不應該用第一種作法，除非你真的很確定你只是需要這個方法</p>\n<p>為什麼說第二種作法比較好呢？因為我們經常性面對的問題通常與 App 開發有關</p>\n<p>因此需要確切型別的機會比較高，而且第二種作法的侵入性低，未來要對介面進行改變也比較容易，同時 Swift 可還有傳統的介面繼承啊！如果真的需要某個方法提供行為，應該用繼承的方式，直接定義在 class 宣告上</p>\n<p>在呼叫轉換函數時，可以看到</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">:</span> xxx<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">:</span> <span class=\"token function\">label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">to</code>接收一個實體，我稱之為<code class=\"language-text\">Target Type instance</code>，只要忽略它的括號，我們就能取得還不錯的可讀性，可喜可賀可喜可賀！</p>\n<h2>hack 2:</h2>\n<blockquote>\n<p>default subset of protocol</p>\n</blockquote>\n<p>如果我們想要做一個新的協定，同時不希望使用者還要浪費時間定義哪些可以符合協定</p>\n<p>我們可以利用<code class=\"language-text\">extension</code></p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">protocol</span> <span class=\"token builtin\">Format</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">extension</span> <span class=\"token builtin\">Double</span> <span class=\"token punctuation\">:</span> <span class=\"token builtin\">Format</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">extension</span> <span class=\"token builtin\">Int</span> <span class=\"token punctuation\">:</span> <span class=\"token builtin\">Format</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>這個 hack 跟上一個 hack 有 87%像，讓他們有差別的地方在於所求不一樣</p>\n<p>hack 2 專注於提供一組符合協定的預設型別集合</p>\n<p>相較於 hack 2，hack 1 只在乎如何讓自訂的型別放進一個泛型容器之中，以及我們怎麼安全的拿出來</p>\n<p>hack 2 的重點是讓某個你提供的<code class=\"language-text\">protocol</code>具有已經具現化的可使用型別集合</p>\n<p>所以我這裡舉了<code class=\"language-text\">Format</code>作為例子，假設你提供了一個<code class=\"language-text\">Format protocol</code>給你的<code class=\"language-text\">Logger</code>函式庫，<code class=\"language-text\">Format protocol</code>要求使用者實作<code class=\"language-text\">format</code>方法，那麼提供一些實作給常用的型別讓人瞻仰你的厲害，不是啦！是讓別人能夠享受某些成果，那麼這個程式庫方能永恆啊！</p>","frontmatter":{"title":"Extension hack","categories":["cs"],"tags":["swift","extension"]}}},"pageContext":{"slug":"/blog/2017/09/29/extension/cs/hack/"}}}