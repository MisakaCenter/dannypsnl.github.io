{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2020/05/16/cs/de-bruijn-index/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>At the beginning of learning PLT, everyone would likely be confused by some program that didn't have a variable! Will, I mean they didn't use <code class=\"language-text\">String</code>, <code class=\"language-text\">Text</code> or something like that to define a variable. A direct mapping definition of lambda calculus(we would use <strong>LC</strong> as the short name in the following context, and if you unfamiliar with <strong>LC</strong>, you can read <a href=\"/blog/2020/01/01/cs/note-what-is-lambda-calculus/\">this article</a> first) usually looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang typed/racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> term [] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> term:var term [<span class=\"token punctuation\">(</span><span class=\"token function\">name</span> : String<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> term:lambda term [<span class=\"token punctuation\">(</span><span class=\"token function\">x</span> : String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">m</span> : term<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> term:application term [<span class=\"token punctuation\">(</span><span class=\"token function\">t1</span> : term<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">t2</span> : term<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span></code></pre></div>\n<p>But what we may find some definitions look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang typed/racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> bterm [] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> bterm:var bterm [<span class=\"token punctuation\">(</span><span class=\"token function\">v</span> : Integer<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> bterm:lambda bterm [<span class=\"token punctuation\">(</span><span class=\"token function\">m</span> : bterm<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> bterm:application bterm [<span class=\"token punctuation\">(</span><span class=\"token function\">t1</span> : bterm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">t2</span> : bterm<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span></code></pre></div>\n<p>There has two significant different:</p>\n<ol>\n<li>variable is an <code class=\"language-text\">Integer</code>.</li>\n<li>lambda does not contain <code class=\"language-text\">x</code>(which means parameter in high-level languages' concept).</li>\n</ol>\n<p>This is De Bruijn index(we would use <strong>DBI</strong> as short name in the following context), we can write it out, for example, <strong>id</strong> function <code class=\"language-text\">λx.x</code> can be rewritten with <code class=\"language-text\">λ0</code>, Y combinator <code class=\"language-text\">λf.(λx.f (x x)) (λx.f (x x))</code> can be rewritten with <code class=\"language-text\">λ(λ0 (1 1))(λ0 (1 1))</code>, but why? To understand <strong>DBI</strong>, we need to know what was the problem in <strong>LC</strong>.</p>\n<h3><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-conversion</h3>\n<p>Usually, two <strong>id</strong> functions considered the same function. However, if we encode <strong>LC</strong> as the first definition written in <strong>racket</strong>, we would get into trouble: We may say <code class=\"language-text\">λx.x</code> is not the same function as <code class=\"language-text\">λy.y</code>, when they are the same. To solve this problem, we developed a conversion called <strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-conversion</strong>(or <strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-renaming</strong>), which renaming <code class=\"language-text\">λx.x</code> and <code class=\"language-text\">λy.y</code> to <code class=\"language-text\">λa.a</code>(<code class=\"language-text\">a</code> is an abstraction variable, we can use any, any character to replace it) let's say. Looks good, any problem else? Emm...yes, as we know, the real world never make thing easier, but that also means a challenge is coming, and we all love the challenge! When a <code class=\"language-text\">λy.λx.x</code> be renamed to <code class=\"language-text\">λa.λa.a</code> is fine, because of every programmer work with variable-shadowing for a long-long time. However, there has a possible dangerous conversion is the renamed variable existed! For example, <code class=\"language-text\">λx.λa.x</code> should not simply be rewritten with <code class=\"language-text\">λa.λa.a</code>, because later when we rename <code class=\"language-text\">a</code>, we would get <code class=\"language-text\">λa.λb.b</code>, oops. <code class=\"language-text\">λx.λa.x</code> definitely is not <code class=\"language-text\">λa.λb.b</code>. To correct <strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span>-conversion</strong> is really hard, that's the main reason we introducing the De Bruijn index.</p>\n<h3>De Bruijn Index</h3>\n<p>We already seem some examples, but why it resolves the problem we mentioned in the previous section? We need to know those rules used by the conversion process:</p>\n<ol>\n<li>remember the level of <code class=\"language-text\">λ</code>, every time we found a <code class=\"language-text\">λ</code> when converting recursively, it should increase(or decrease, it depends on index order) this level value.</li>\n<li>when found a <code class=\"language-text\">λ</code>, replace it's <code class=\"language-text\">x</code> by variable using the De Bruijn index form, the value of the index is the current level.</li>\n</ol>\n<p>Let's manually do this conversion:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">λx.λy.λz.z\n-&gt; λλy.λz.z // x = cur_level = 0, cur_level+1\n-&gt; λλλz.z   // y = cur_level = 1, cur_level+1\n-&gt; λλλ2 // z = cur_level = 2</code></pre></div>\n<p>Notice that since new form of abstraction(a.k.a lambda) only needs <code class=\"language-text\">M</code> part(a.k.a. body). Another important thing is some De Bruijn index use reverse order than we show at here, so would be <code class=\"language-text\">λλλ0</code>, not <code class=\"language-text\">λλλ2</code>.</p>\n<h4>Implementation</h4>\n<p>Now, it's time for the program:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> convert <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> [term] [<span class=\"token punctuation\">(</span><span class=\"token function\">Immutable-HashTable</span> String Integer<span class=\"token punctuation\">)</span>] bterm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">convert</span> t [rename-to <span class=\"token punctuation\">(</span><span class=\"token function\">make-immutable-hash</span> <span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> t\n    <span class=\"token comment\">;; get index from environment</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[term:var</span> name] <span class=\"token punctuation\">(</span><span class=\"token function\">bterm:var</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hash-ref</span> rename-to name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[term:lambda</span> p b]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">bterm:lambda</span>\n      <span class=\"token punctuation\">(</span><span class=\"token function\">convert</span> b\n               <span class=\"token comment\">;; bind parameter name to an index</span>\n               <span class=\"token punctuation\">(</span><span class=\"token function\">hash-set</span> rename-to p <span class=\"token punctuation\">(</span><span class=\"token function\">hash-count</span> rename-to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[term:application</span> t1 t2]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">bterm:application</span>\n      <span class=\"token punctuation\">(</span><span class=\"token function\">convert</span> t1 rename-to<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">(</span><span class=\"token function\">convert</span> t2 rename-to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">-&gt;*</code> is a type constructor in <strong>Racket</strong> for <strong>optional</strong> parameters, should be read like <code class=\"language-text\">(-&gt;* normal-parameter-types optional-parameter-types return-type)</code>. I use optional parameters to help users don't need to remember they must provide an empty hash table. A tricky thing is I didn't record level, at least, not directly. Here I use an immutable hash table to remember level, since how many variables should be renamed exactly is level value. Then variable only need to replace its name with the index.</p>\n<p>Congratulation, now you know everything about <strong>DBI</strong>!? No, not yet, there still one thing you need to know.</p>\n<h3><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction</h3>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction? You might think how can such basic things make things go wrong. However, a naive implementation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction can break structural equivalence of <strong>DBI</strong> form, which can make an annoying bug in those systems based on <strong>LC</strong>. The problem is lack-lifting. For example, a normal implementation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction would simply make <code class=\"language-text\">λ(λλ2 0)</code> become <code class=\"language-text\">λλ2</code>. However, the same form directly converted from <code class=\"language-text\">λx.λz.z</code> would become <code class=\"language-text\">λλ1</code>, and <code class=\"language-text\">λλ2</code> will be considered as different value as <code class=\"language-text\">λλ1</code> since <code class=\"language-text\">1</code> is not <code class=\"language-text\">2</code>. We can introduce another renaming for these, but if we can fix it in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction, why need another phase?</p>\n<h4>Implementation</h4>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre style=\"counter-reset: linenumber 0\" class=\"language-scheme line-numbers\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> beta-reduction <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> [bterm] [Integer <span class=\"token punctuation\">(</span><span class=\"token function\">Immutable-HashTable</span> Integer bterm<span class=\"token punctuation\">)</span>] bterm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">beta-reduction</span> t [de-bruijn-level <span class=\"token number\">0</span>] [subst <span class=\"token punctuation\">(</span><span class=\"token function\">make-immutable-hash</span> <span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> t\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[bterm:var</span> i]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">hash-ref</span> subst i <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[bterm:lambda</span> body]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">bterm:lambda</span> <span class=\"token punctuation\">(</span><span class=\"token function\">beta-reduction</span> body <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token number\">1</span> de-bruijn-level<span class=\"token punctuation\">)</span> subst<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[bterm:application</span> t1 t2]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> t1\n       <span class=\"token punctuation\">(</span><span class=\"token function\">[bterm:lambda</span> body]\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[reduced-term</span> <span class=\"token punctuation\">(</span><span class=\"token function\">beta-reduction</span> body <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token number\">1</span> de-bruijn-level<span class=\"token punctuation\">)</span>\n                                            <span class=\"token punctuation\">(</span><span class=\"token function\">hash-set</span> subst de-bruijn-level t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n          <span class=\"token comment\">;;; dbi lifting by replace reduced-term (+ 1 dbi) with (var dbi)</span>\n          <span class=\"token punctuation\">(</span><span class=\"token function\">beta-reduction</span> reduced-term de-bruijn-level\n                          <span class=\"token punctuation\">(</span><span class=\"token function\">hash-set</span> subst <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token number\">1</span> de-bruijn-level<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">bterm:var</span> de-bruijn-level<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token function\">_</span> <span class=\"token punctuation\">(</span><span class=\"token function\">raise</span> <span class=\"token string\">\"cannot do application on non-lambda term\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We have to record level independently since it has no relation with the substitution map this time. For variables, all need to do is apply substitution map to get value, if not, use origin form as a result. For the lambda, increase level is the only thing. For application, it's complicated. We need to be more careful with it. It contains three major parts:</p>\n<ol>\n<li>check <code class=\"language-text\">t1</code> is an abstraction(a.k.a lambda), line 9 and 16</li>\n<li>do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05278em;\">β</span></span></span></span>-reduction by add stuff into substitution map, line 11 to 12</li>\n<li><strong>DBI</strong> lifting (for example, <code class=\"language-text\">λλ2</code> should become <code class=\"language-text\">λλ1</code>), line 14 to 15</li>\n</ol>\n<h3>Conclusion</h3>\n<p><strong>DBI</strong> is a quite useful technology when implementing complicated AST conversion. It's not just easier to avoid rename conflicting, but also a less memory required form for implementations. I hope you enjoy the article and have a nice day, if this even really helps you in a real task, would be awesome!</p>","frontmatter":{"title":"De Bruijn index: why and how","categories":["cs"],"tags":["plt","de bruijn index","racket"]}}},"pageContext":{"slug":"/blog/2020/05/16/cs/de-bruijn-index/"}}}