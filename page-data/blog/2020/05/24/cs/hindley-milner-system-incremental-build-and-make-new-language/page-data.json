{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2020/05/24/cs/hindley-milner-system-incremental-build-and-make-new-language/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>Hindley-Milner (HM) type system is a classical type system for lambda calculus with parametric polymorphism. Its most notable property is it can infer most types of a given program, <strong>without type annotations</strong>! However, this feature sounds cool but not work well in practice XD, since people need annotation to hint ourselves when reading. I pick this system as a topic is because the HM type system probably is the easiest completeness system with parametric polymorphism. It's a good start for understanding other more complex type systems, and it's important for gradual typing. But before we dig too deep into those ideas, let's start to understand HM, the point of this article.</p>\n<h3>Why?</h3>\n<p>In earlier days Lisp didn't have a type system, as time pass, people start to want to(or need to) express program more precisely since cooperation and robustness. Then people start working for their needs. To express a <code class=\"language-text\">list</code>, introduce <strong>parametric polymorphism</strong>. <strong>parametric polymorphism</strong> sounds scared but doesn't, let's view an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> list-length <span class=\"token punctuation\">(</span><span class=\"token function\">All</span> <span class=\"token punctuation\">(</span><span class=\"token function\">A</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> <span class=\"token punctuation\">(</span><span class=\"token function\">Listof</span> A<span class=\"token punctuation\">)</span> Integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This syntax bind <code class=\"language-text\">list-length</code> to a type <code class=\"language-text\">(All (A) (-&gt; (List A) Integer))</code>, or we would write <code class=\"language-text\">list-length : (All (A) (-&gt; (List A) Integer))</code>(you can see <strong>Racket</strong> use prefix operator, very Lisp style, not surprise XD). The syntax is not the most important thing, but it shows a very common thing in many different languages, to help you get what is <strong>parametric polymorphism</strong>. Now imagine, every time call <code class=\"language-text\">list-length</code>, must provide <code class=\"language-text\">A</code> as an argument: <code class=\"language-text\">(list-length Number lst)</code>. People would get tired and say: I hate the static type system, it seems no surprise. That's the reason for type inference. With type inference, if <code class=\"language-text\">lst : (Listof Number)</code>, <code class=\"language-text\">A</code> is <code class=\"language-text\">Number</code>, get type without type! The idea is so frustrating and makes people crazy to think about: Can we have a system, get all the type without type? The result is the HM type system.</p>\n<h4>Why Polymorphism</h4>\n<p>In <a href=\"/blog/2020/03/08/cs/note-stlc/\">simply typed lambda calculus (STLC)</a>, asking <strong>e : T</strong> make sense because we already give <code class=\"language-text\">e</code> a type <code class=\"language-text\">K</code>, check <code class=\"language-text\">T</code> is <code class=\"language-text\">K</code> is all we need. All type in STLC is a <code class=\"language-text\">T</code> or <code class=\"language-text\">T -&gt; T</code> and <code class=\"language-text\">T</code> will not from another type. This feature, however, makes inconvenience when writing a program, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> id\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Identity function can work well with any type, but now we have to provide infinite versions for it:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> id-str <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> str str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> id-str <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> id-int <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> int int<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> id-int <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> id-bool <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> bool bool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> id-bool <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> id-int-to-int <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> int int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> int int<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> id-int-to-int <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>If I don't want it and still want types, then use polymorphism is the solution:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> id <span class=\"token punctuation\">(</span><span class=\"token function\">All</span> <span class=\"token punctuation\">(</span><span class=\"token function\">A</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> A A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> id\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>I hope I convince you that, take your time to understand its detail of this system is valuable :).</p>\n<h3>Setup a project</h3>\n<p>This section helps you get a project would be modified in the following part:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">raco pkg new hindley-milner\n<span class=\"token builtin class-name\">cd</span> hindley-milner\nraco pkg <span class=\"token function\">install</span> --auto</code></pre></div>\n<h3>Syntax Overview</h3>\n<p>I would show a small enough language can cooperate with HM type system and big enough to convince you this is useful, detail would not be the point, put them at here is just want to help you keep going with the following content.</p>\n<ul>\n<li>Definition of language(create <code class=\"language-text\">lang.rkt</code>):</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang typed/racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">provide</span> expr expr:int expr:bool expr:string expr:list expr:variable expr:lambda expr:application expr:let<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr [] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:int expr [<span class=\"token punctuation\">(</span><span class=\"token function\">v</span> : Integer<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:bool expr [<span class=\"token punctuation\">(</span><span class=\"token function\">v</span> : Boolean<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:string expr [<span class=\"token punctuation\">(</span><span class=\"token function\">v</span> : String<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:list expr [<span class=\"token punctuation\">(</span><span class=\"token function\">elems</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Listof</span> expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:variable expr [<span class=\"token punctuation\">(</span><span class=\"token function\">name</span> : String<span class=\"token punctuation\">)</span>] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:lambda expr\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">param</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Listof</span> String<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">(</span><span class=\"token function\">body</span> : expr<span class=\"token punctuation\">)</span>]\n  #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:application expr\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">func</span> : expr<span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">(</span><span class=\"token function\">args</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Listof</span> expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]\n  #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> expr:let expr\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">bindings</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Listof</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Pair</span> String expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">(</span><span class=\"token function\">expr</span> : expr<span class=\"token punctuation\">)</span>]\n  #:transparent<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Definition of types(create <code class=\"language-text\">typ.rkt</code>)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang typed/racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">provide</span> typ typ:builtin<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> typ [] #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> typ:builtin typ\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">name</span> : String<span class=\"token punctuation\">)</span>]\n  #:transparent<span class=\"token punctuation\">)</span></code></pre></div>\n<p>I will not explain them immediately, but let our incrementally steps show the story, let's start the journey.</p>\n<h3>Part I: Incrementally build up inference</h3>\n<p>Then we learn how to incrementally build up the HM type system without memorizing all rules. It also shows how to get ideas behind rules, not just remember a snapshot!</p>\n<h4>Monomorphism stuff</h4>\n<p><strong>Monomorphism</strong>, which means obviously and decidable, and it would be a good start. Here, code can explain it better(create <code class=\"language-text\">semantic.rkt</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang typed/racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">provide</span> type/infer<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">require</span> <span class=\"token string\">\"lang.rkt\"</span>\n         <span class=\"token string\">\"typ.rkt\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> type/infer <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> expr typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> exp<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> exp\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:int</span> _] <span class=\"token punctuation\">(</span><span class=\"token function\">typ:builtin</span> <span class=\"token string\">\"int\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:bool</span> _] <span class=\"token punctuation\">(</span><span class=\"token function\">typ:builtin</span> <span class=\"token string\">\"bool\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:string</span> _] <span class=\"token punctuation\">(</span><span class=\"token function\">typ:builtin</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>You can see why I say they are obviously even you never use <strong>static type</strong>, because this type is builtin in most language, inference their types is just by definition. <code class=\"language-text\">1</code> is <code class=\"language-text\">int</code>, <code class=\"language-text\">#t</code> is <code class=\"language-text\">bool</code>, <code class=\"language-text\">&quot;hello&quot;</code> is <code class=\"language-text\">string</code>. However, there has a common <strong>builtin</strong> type is not monomorphism, for example: <code class=\"language-text\">list</code>.</p>\n<h4>List</h4>\n<p>The inference list type is not that easy, because it's a type depends on the type, what's that mean? It means we say: <code class=\"language-text\">list A</code> is a type when <code class=\"language-text\">A</code> is a type, so must have a type <code class=\"language-text\">A</code> to have type <code class=\"language-text\">list A</code>, this called type depends on the type. This means, if we want to inference type of list, we also need to inference the type of its element and check rest elements following the same type. An edge case is somehow, some lists do not contain any element, in such case we still need a type, so we give it a placeholder of the type usually called <strong>free type variable(freevar)</strong>. Finally, returns a type <code class=\"language-text\">list</code> with its type of argument. You can try to build it by yourself, but you would find there is something missing and became a wall stop you. The first thing we need to do, is extending our type definition to fit <strong>a type with type parameter</strong> this abstraction(modify <code class=\"language-text\">typ.rkt</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> typ:freevar typ\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">index</span> : Integer<span class=\"token punctuation\">)</span>]\n  #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> typ:constructor typ\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">name</span> : String<span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">(</span><span class=\"token function\">arg</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Listof</span> typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]\n  #:transparent<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> typ:builtin <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> String typ:constructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">typ:builtin</span> name<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">typ:constructor</span> name <span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now <code class=\"language-text\">typ:builtin</code> is just a special case of <code class=\"language-text\">typ:constructor</code>, and we introduce the placeholder: <code class=\"language-text\">typ:freevar</code>. The second thing need to prepare is <strong>Context</strong>(modify <code class=\"language-text\">semantic.rkt</code>, put them before <code class=\"language-text\">type/infer</code>), which maintaining the state of <code class=\"language-text\">freevar</code> counting:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> Context\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">freevar-counter</span> : Integer<span class=\"token punctuation\">)</span>]\n  #:transparent\n  #:mutable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> Context/new <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> Context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context/new</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">Context</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> Context/new-freevar! <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> Context typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context/new-freevar!</span> ctx<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[cur-count</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context-freevar-counter</span> ctx<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">set-Context-freevar-counter!</span> ctx <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context-freevar-counter</span> ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">typ:freevar</span> cur-count <span class=\"token boolean\">#f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Then we can start adding inference of <code class=\"language-text\">expr:list</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> unify <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> typ typ Void<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> t1 t2<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> t1 t2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[cons</span> <span class=\"token punctuation\">(</span><span class=\"token function\">typ:constructor</span> a al<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">typ:constructor</span> b bl<span class=\"token punctuation\">)</span>]\n     #:when <span class=\"token punctuation\">(</span><span class=\"token function\">string=?</span> a b<span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">(</span><span class=\"token function\">for-each</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">ae</span> : typ<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">be</span> : typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                 <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> ae be<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n               al bl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">_</span> <span class=\"token punctuation\">(</span><span class=\"token function\">raise</span> <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"cannot unify type ~a and ~a\"</span> t1 t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">; ->* is a special type, which means `->* list-of-required-parameters list-of-optional-parameters return-type`</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> type/infer <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> <span class=\"token punctuation\">(</span><span class=\"token function\">expr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context</span><span class=\"token punctuation\">)</span> typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> exp<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> exp\n    <span class=\"token comment\">; ignore</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:string</span> _] <span class=\"token punctuation\">(</span><span class=\"token function\">typ:builtin</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:list</span> elems]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">typ:constructor</span> <span class=\"token string\">\"list\"</span>\n                      <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">empty?</span> elems<span class=\"token punctuation\">)</span>\n                        <span class=\"token punctuation\">(</span><span class=\"token function\">Context/new-freevar!</span> ctx<span class=\"token punctuation\">)</span>\n                        <span class=\"token comment\">; use first element type as type of all elements</span>\n                        <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[elem-typ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">car</span> elems<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span> <span class=\"token comment\">; (car (list 1 2 3)) is 1</span>\n                          <span class=\"token comment\">; check all elements follow first element type</span>\n                          <span class=\"token punctuation\">(</span><span class=\"token function\">for-each</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[elem</span> : expr]<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> elem-typ <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> elem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                            <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span> elems<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">; (cdr (list 1 2 3)) is (list 2 3)</span>\n                          elem-typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Currently, <code class=\"language-text\">unify</code> just check two constructors has the same name, and keep <code class=\"language-text\">unify</code> their parameters if has. In other cases, throw an exception.</p>\n<h4>Variable</h4>\n<p>A variable would have a type, or it binds with a type. Anyway, that means we can infer the type of variable, but we need a place to store this information. Therefore, a new abstraction introduced <strong>Environment</strong>(modify <code class=\"language-text\">semantic.rkt</code>, put code before <code class=\"language-text\">Context</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> Env\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">parent</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Option</span> Env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">(</span><span class=\"token function\">type-env</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Mutable-HashTable</span> String typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]\n  #:transparent\n  #:mutable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> Env/new <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">Option</span> Env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> Env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Env/new</span> [parent <span class=\"token boolean\">#f</span>]<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">Env</span> parent <span class=\"token punctuation\">(</span><span class=\"token function\">make-hash</span> <span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">;;; Env/lookup take variable name such as `x` to get a type from env</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> Env/lookup <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> Env String typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Env/lookup</span> env var-name<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">:</span> lookup-parent <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> lookup-parent <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                          <span class=\"token punctuation\">(</span><span class=\"token function\">:</span> parent <span class=\"token punctuation\">(</span><span class=\"token function\">Option</span> Env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                          <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> parent <span class=\"token punctuation\">(</span><span class=\"token function\">Env-parent</span> env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                          <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> parent\n                              <span class=\"token comment\">; dispatch to parent if we have one</span>\n                              <span class=\"token punctuation\">(</span><span class=\"token function\">Env/lookup</span> parent var-name<span class=\"token punctuation\">)</span>\n                              <span class=\"token comment\">; really fail if we have no parent environment</span>\n                              <span class=\"token punctuation\">(</span><span class=\"token function\">raise</span> <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"no variable named: `~a`\"</span> var-name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">; try to get value from table</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[typ-env</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Mutable-HashTable</span> String typ<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Env-type-env</span> env<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">hash-ref</span> typ-env var-name\n              <span class=\"token comment\">; if fail, handler would take</span>\n              lookup-parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>then add a new field into <code class=\"language-text\">Context</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">struct</span> Context\n  [<span class=\"token punctuation\">(</span><span class=\"token function\">freevar-counter</span> : Integer<span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">(</span><span class=\"token function\">type-env</span> : Env<span class=\"token punctuation\">)</span>]\n  #:transparent\n  #:mutable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> Context/new <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> Context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context/new</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">Context</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Env/new</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now we can get the variable type from <code class=\"language-text\">Context</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> type/infer <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> <span class=\"token punctuation\">(</span><span class=\"token function\">expr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context</span><span class=\"token punctuation\">)</span> typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; ignore</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:variable</span> name] <span class=\"token punctuation\">(</span><span class=\"token function\">Env/lookup</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context-type-env</span> ctx<span class=\"token punctuation\">)</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Wait, we use variable then must somewhere we define it, where is it? Therefore, the next section is lambda, lambda would introduce new variables into the environment.</p>\n<h4>Lambda</h4>\n<p>Things are getting more complex, get really to understand what we need to do? Lambda in the HM system well not have type annotation for parameters, it causes the same problem just like what <code class=\"language-text\">list</code> gives us. This means we need to bind a <code class=\"language-text\">freevar</code> with parameters as variables into a <strong>new environment</strong>. At here, since the multiple parameters are valid in this language, I introduce type <code class=\"language-text\">pair</code> to abstraction on this rather than extend type definition. Then, we use this new environment to infer the type of body, and produce arrow type(If you don't understand arrow type, I suggest you read <a href=\"/blog/2020/03/08/cs/note-stlc/\">STLC</a> for explanation) via the inferred result. Now, it's time for some program:</p>\n<h5>Bind variable</h5>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> Env/bind-var <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> Env String typ Void<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Env/bind-var</span> env var-name typ<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[env</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Env-type-env</span> env<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">hash-has-key?</span> env var-name<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token function\">raise</span> <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"redefined: `~a`\"</span> var-name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token function\">hash-set!</span> env var-name typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h5>Infer</h5>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> type/infer <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> <span class=\"token punctuation\">(</span><span class=\"token function\">expr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context</span><span class=\"token punctuation\">)</span> typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; ignore</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:lambda</span> params body]\n     <span class=\"token comment\">; params use new freevars as their type</span>\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">letrec</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[λ-env</span> : Env <span class=\"token punctuation\">(</span><span class=\"token function\">Env/new</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context-type-env</span> ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]\n           [param-types <span class=\"token punctuation\">(</span><span class=\"token function\">typ:constructor</span>\n                         <span class=\"token string\">\"pair\"</span>\n                         <span class=\"token punctuation\">(</span><span class=\"token function\">map</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[param-name</span> : String]<span class=\"token punctuation\">)</span>\n                                <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[r</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context/new-freevar!</span> ctx<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n                                  <span class=\"token punctuation\">(</span><span class=\"token function\">Env/bind-var</span> λ-env param-name r<span class=\"token punctuation\">)</span>\n                                  r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token function\">set-Context-type-env!</span> ctx λ-env<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> body-typ <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> body ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token function\">typ:arrow</span> param-types body-typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>WARN: notice since I always invoke <code class=\"language-text\">type/infer</code> without context in outside, <code class=\"language-text\">type-env</code> no need to set back to the original one. However, if you extend this language with <code class=\"language-text\">define</code> such sharing <code class=\"language-text\">Context</code>, then set environment back is required, else your local bindings would affect the outer scope.</p>\n</blockquote>\n<p>Lambda seems powerful, and let can be translated to lambda, right? Unfortunately, it's correct in the computation view, but incorrect in the inference view. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">id</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">id</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>It gets an identity function and applies to <code class=\"language-text\">1</code>, it seems like it should get <code class=\"language-text\">int</code>. However, we would get a <code class=\"language-text\">freevar</code>. Because no one requires <code class=\"language-text\">id</code> start infer its type since we have no idea when would lambda apply to something, if remove <code class=\"language-text\">(λ (a) a)</code> and application form outside of <code class=\"language-text\">(λ (id) (id 1))</code>, we cannot ensure the type of <code class=\"language-text\">(id 1)</code>. That's what let polymorphism going to solve.</p>\n<h4>Let polymorphism</h4>\n<p>Let polymorphism is the key expression in the HM type system, which ensures inference is decidable. The problem in the previous section can be fixed if using <code class=\"language-text\">let</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[id</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">id</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Because <code class=\"language-text\">let</code> would infer the type of <code class=\"language-text\">id</code> immediately. Then the problem would be eliminated. So the only different part between <code class=\"language-text\">let</code> and <code class=\"language-text\">lambda</code>, is <code class=\"language-text\">let</code> bind its variable with inferred type, not <code class=\"language-text\">freevar</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> type/infer <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> <span class=\"token punctuation\">(</span><span class=\"token function\">expr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context</span><span class=\"token punctuation\">)</span> typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; ignore</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:let</span> bindings exp]\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">letrec</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[let-env</span> : Env <span class=\"token punctuation\">(</span><span class=\"token function\">Env/new</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context-type-env</span> ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]\n              [bind-to-context <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[bind</span> : <span class=\"token punctuation\">(</span><span class=\"token function\">Pairof</span> String expr<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n                                 <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> bind\n                                   <span class=\"token punctuation\">(</span><span class=\"token function\">[cons</span> name init]\n                                    <span class=\"token punctuation\">(</span><span class=\"token function\">Env/bind-var</span> let-env name <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> init ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token function\">map</span> bind-to-context bindings<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token function\">set-Context-type-env!</span> ctx let-env<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> exp ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Finally, we came to infer the last expression: <code class=\"language-text\">expr:application</code>.</p>\n<h4>Application</h4>\n<p>Infer <code class=\"language-text\">application</code> needs to do a few checks:</p>\n<ol>\n<li>For application <code class=\"language-text\">(func args ...)</code>, infer the type of <code class=\"language-text\">func</code>.</li>\n<li>Check type of <code class=\"language-text\">func</code> is a arrow type: <code class=\"language-text\">A -&gt; B</code>.</li>\n<li>Assume return type is a <code class=\"language-text\">freevar</code>.</li>\n<li>Unify <code class=\"language-text\">A -&gt; B</code> with <code class=\"language-text\">(typeof (args ...)) -&gt; freevar</code>.</li>\n<li>return <code class=\"language-text\">freevar</code> as infer result.</li>\n</ol>\n<p>With the explanation, we can start coding:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> type/infer <span class=\"token punctuation\">(</span><span class=\"token function\">->*</span> <span class=\"token punctuation\">(</span><span class=\"token function\">expr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">Context</span><span class=\"token punctuation\">)</span> typ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; ignore</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[expr:application</span> fn args]\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[fn-typ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> fn ctx<span class=\"token punctuation\">)</span>]\n           [args-typ <span class=\"token punctuation\">(</span><span class=\"token function\">map</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">arg</span> : expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> arg ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> args<span class=\"token punctuation\">)</span>]\n           [fresh <span class=\"token punctuation\">(</span><span class=\"token function\">Context/new-freevar!</span> ctx<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n       <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> fn-typ <span class=\"token punctuation\">(</span><span class=\"token function\">typ:arrow</span> <span class=\"token punctuation\">(</span><span class=\"token function\">typ:constructor</span> <span class=\"token string\">\"pair\"</span> args-typ<span class=\"token punctuation\">)</span> fresh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n       fresh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">; don't forget to close parenthesis!</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We almost complete, but we have new jobs in <code class=\"language-text\">unify</code> to do since application might unify <code class=\"language-text\">freevar</code> and arrow type now.</p>\n<h5>Unify freevar</h5>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> unify <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> typ typ Void<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> t1 t2<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> t1 t2<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; ignore</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[cons</span> <span class=\"token punctuation\">(</span><span class=\"token function\">typ:arrow</span> p1 r1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">typ:arrow</span> p2 r2<span class=\"token punctuation\">)</span>]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> p1 p2<span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> r1 r2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">;;; freevar type is only important thing in `unify` function</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">and</span>\n      [cons _ <span class=\"token punctuation\">(</span><span class=\"token function\">typ:freevar</span> _ _<span class=\"token punctuation\">)</span>]\n      [cons t v]<span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">or</span> <span class=\"token punctuation\">(</span><span class=\"token function\">eqv?</span> v t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">not</span> <span class=\"token punctuation\">(</span><span class=\"token function\">occurs</span> v t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">(</span><span class=\"token function\">subst!</span> v t<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">(</span><span class=\"token function\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">(</span><span class=\"token function\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[cons</span> <span class=\"token punctuation\">(</span><span class=\"token function\">typ:freevar</span> _ _<span class=\"token punctuation\">)</span> t2] <span class=\"token punctuation\">(</span><span class=\"token function\">unify</span> t2 t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; ignore</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Unify arrow type is simple, in fact, we can totally replace <code class=\"language-text\">typ:arrow</code> with <code class=\"language-text\">typ:constructor</code> XD. In fact, all type constructors can be <code class=\"language-text\">unify</code> in the same way. <code class=\"language-text\">freevar</code> brings a new thing: <code class=\"language-text\">occurs</code>, what's <code class=\"language-text\">occurs</code>?</p>\n<h5>Occurs check</h5>\n<p>Occurs check make unification fail when unify <code class=\"language-text\">V</code> and <code class=\"language-text\">T</code>, <code class=\"language-text\">T</code> contains <code class=\"language-text\">V</code>. If we didn't do this check, <code class=\"language-text\">unify</code> would lead to unsound inference, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token operator\">=</span> ?0 <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> ?0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>What would <code class=\"language-text\">?0</code> be? It would cause an infinite loop at there: <code class=\"language-text\">(list (list (list ...)))</code>. Therefore, we need to check if <code class=\"language-text\">V</code> occurs in <code class=\"language-text\">T</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">:</span> occurs <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> typ typ Boolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">occurs</span> v t<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> v t<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; same freevar means `v` occurs in `t`, then should be rejected</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[cons</span> v <span class=\"token punctuation\">(</span><span class=\"token function\">typ:freevar</span> _ _<span class=\"token punctuation\">)</span>] <span class=\"token punctuation\">(</span><span class=\"token function\">eqv?</span> v t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; arrow and constructor both just keep check on type parameters</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[cons</span> v <span class=\"token punctuation\">(</span><span class=\"token function\">typ:arrow</span> t1 t2<span class=\"token punctuation\">)</span>] <span class=\"token punctuation\">(</span><span class=\"token function\">or</span> <span class=\"token punctuation\">(</span><span class=\"token function\">occurs</span> v t1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">occurs</span> v t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[cons</span> v <span class=\"token punctuation\">(</span><span class=\"token function\">typ:constructor</span> _ type-params<span class=\"token punctuation\">)</span>]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">foldl</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[t</span> : typ] [pre-bool : Boolean]<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">(</span><span class=\"token function\">or</span> pre-bool <span class=\"token punctuation\">(</span><span class=\"token function\">occurs</span> v t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token boolean\">#f</span>\n            type-params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">; rest is fine</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">_</span> false<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now, the whole inference part done, if you want to know how to build a new language in Racket then keep going, or you can close the tab now XD.</p>\n<h3>Part Two: Make new language in Racket</h3>\n<p>After we build up a type system, we definitely want to see it work as a language, and make a new language in Racket is crazy easy! Let's start the second part.</p>\n<h4>Pretty Print</h4>\n<p>First, to improve readability, we need pretty-print function(create <code class=\"language-text\">pretty-print.rkt</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang typed/racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">require</span> <span class=\"token string\">\"typ.rkt\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">provide</span> pretty-print-typ<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">:</span> pretty-print-typ <span class=\"token punctuation\">(</span><span class=\"token function\">-></span> typ String<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> t<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> t\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[typ:freevar</span> idx subst]\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> subst\n         <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> subst<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"?~a\"</span> idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[typ:constructor</span> name typ-args]\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">empty?</span> typ-args<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"~a\"</span> name<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[j</span> <span class=\"token punctuation\">(</span><span class=\"token function\">string-join</span> <span class=\"token punctuation\">(</span><span class=\"token function\">map</span>\n                                <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[typ-arg</span> : typ]<span class=\"token punctuation\">)</span>\n                                  <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> typ-arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                                typ-args<span class=\"token punctuation\">)</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n           <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">string=?</span> name <span class=\"token string\">\"pair\"</span><span class=\"token punctuation\">)</span>\n               <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"(~a)\"</span> j<span class=\"token punctuation\">)</span>\n               <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"(~a ~a)\"</span> name j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">[typ:arrow</span> from to]\n     <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"~a -> ~a\"</span> <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> from<span class=\"token punctuation\">)</span>\n             <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>and we modify the <code class=\"language-text\">unify</code> function in <code class=\"language-text\">semantic.rkt</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">_</span> <span class=\"token punctuation\">(</span><span class=\"token function\">raise</span> <span class=\"token punctuation\">(</span><span class=\"token function\">format</span> <span class=\"token string\">\"cannot unify type ~a and ~a\"</span> <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> t1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>For example: <code class=\"language-text\">(typ:arrow (typ:constructor &quot;int&quot; &#39;()) (typ:constructor &quot;int&quot; &#39;()))</code> would be <code class=\"language-text\">int -&gt; int</code>, very good.</p>\n<h4>Macro for module language</h4>\n<p>Then we start handling macros in Racket, to handle the whole module, we need to overwrite <code class=\"language-text\">#%module-begin</code>(modify <code class=\"language-text\">main.rkt</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">require</span> <span class=\"token punctuation\">(</span><span class=\"token function\">for-syntax</span> syntax/parse<span class=\"token punctuation\">)</span>\n         racket/syntax\n         syntax/stx<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">require</span> <span class=\"token string\">\"lang.rkt\"</span>\n         <span class=\"token string\">\"semantic.rkt\"</span>\n         <span class=\"token string\">\"pretty-print.rkt\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">provide</span> <span class=\"token punctuation\">(</span><span class=\"token function\">except-out</span> <span class=\"token punctuation\">(</span><span class=\"token function\">all-from-out</span> racket<span class=\"token punctuation\">)</span> #%module-begin<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">(</span><span class=\"token function\">rename-out</span> [module-begin #%module-begin]<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">define-syntax-rule</span> <span class=\"token punctuation\">(</span><span class=\"token function\">module-begin</span> EXPR ...<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">#%module-begin</span>\n   <span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> all-form <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> EXPR<span class=\"token punctuation\">)</span> ...<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">(</span><span class=\"token function\">for-each</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">form</span><span class=\"token punctuation\">)</span>\n               <span class=\"token punctuation\">(</span><span class=\"token function\">displayln</span> form<span class=\"token punctuation\">)</span>\n               <span class=\"token punctuation\">(</span><span class=\"token function\">printf</span> <span class=\"token string\">\"type:- ~a~n\"</span> <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> form<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n             all-form<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We haven't defined <code class=\"language-text\">parse</code>, here shows how to get all forms in the module and handling them by <code class=\"language-text\">for-each</code>, then is <code class=\"language-text\">parse</code> part:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define-syntax</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> stx<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">define-syntax-class</span> bind\n    <span class=\"token punctuation\">(</span><span class=\"token function\">pattern</span> <span class=\"token punctuation\">(</span><span class=\"token function\">bind-name:id</span> bind-expr<span class=\"token punctuation\">)</span>\n             #:with bind\n             #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">cons</span> <span class=\"token punctuation\">(</span><span class=\"token function\">symbol->string</span> <span class=\"token string\">'bind-name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> bind-expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">syntax-parse</span> stx\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`[</span><span class=\"token punctuation\">(</span><span class=\"token function\">~literal</span> let<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">binding*:bind</span> ...<span class=\"token punctuation\">)</span> body]\n     #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:let</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> binding*.bind ...<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`[</span><span class=\"token punctuation\">(</span><span class=\"token function\">~literal</span> λ<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">ps*</span> ...<span class=\"token punctuation\">)</span> body] #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:lambda</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token punctuation\">(</span><span class=\"token function\">symbol->string</span> <span class=\"token string\">'ps*</span><span class=\"token punctuation\">)</span> ...<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`[</span><span class=\"token punctuation\">(</span><span class=\"token function\">~literal</span> quote<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token function\">elem*</span> ...<span class=\"token punctuation\">)</span>] #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:list</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> elem*<span class=\"token punctuation\">)</span> ...<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`[f</span> arg* ...] #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:application</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> f<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> arg*<span class=\"token punctuation\">)</span> ...<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`v:id</span> #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:variable</span> <span class=\"token punctuation\">(</span><span class=\"token function\">symbol->string</span> <span class=\"token string\">'v</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`s:string</span> #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:string</span> <span class=\"token punctuation\">(</span><span class=\"token function\">#%datum</span> . s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`b:boolean</span> #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:bool</span> <span class=\"token punctuation\">(</span><span class=\"token function\">#%datum</span> . b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">`i:exact-integer</span> #<span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token function\">expr:int</span> <span class=\"token punctuation\">(</span><span class=\"token function\">#%datum</span> . i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">;;; module-begin</span></code></pre></div>\n<p>Just mapping <strong>S expression</strong> to expression defined in <code class=\"language-text\">lang.rkt</code>.</p>\n<h5>Module reader</h5>\n<p>Define a <code class=\"language-text\">module reader</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">module</span> reader syntax/module-reader\n  hindley-milner<span class=\"token punctuation\">)</span></code></pre></div>\n<p>With these, you can use <code class=\"language-text\">#lang hindley-milner</code> as new Racket program:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang hindley-milner\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token function\">[a</span> <span class=\"token number\">1</span>]\n      [b <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">x</span><span class=\"token punctuation\">)</span> x<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">b</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Run it can see program prints expressions' structure and type.</p>\n<h5>REPL</h5>\n<p>The final thing to do, that's REPL supporting, we need to overwrite <code class=\"language-text\">#%top-interaction</code> to make it:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token function\">provide</span> <span class=\"token punctuation\">(</span><span class=\"token function\">except-out</span> <span class=\"token punctuation\">(</span><span class=\"token function\">all-from-out</span> racket<span class=\"token punctuation\">)</span> #%module-begin #%top-interaction<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">(</span><span class=\"token function\">rename-out</span> [module-begin #%module-begin]\n                     [top-interaction #%top-interaction]<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">define-syntax-rule</span> <span class=\"token punctuation\">(</span><span class=\"token function\">top-interaction</span> . exp<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">pretty-print-typ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">type/infer</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parse</span> exp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>It gives a type after pretty print for input in REPL. Finally, we complete this journey.</p>\n<h3>Conclusion</h3>\n<p>I hope detailed implementation and examples show why we need the HM system, and how to make one, and where we would need it. I would be glad to hear you get help from this article. Have a nice day, and it's time for cookies!</p>\n<p>p.s. This is probably the second-longest article I made XD.</p>","frontmatter":{"title":"Hindley-Milner type system: Incrementally build way & Make new language in Racket","categories":["cs"],"tags":["plt","hindley milner","racket"]}},"allMarkdownRemark":{"edges":[{"node":{"id":"7b2485d7-e7c3-57fd-9547-16fd402b114d","frontmatter":{"title":"How to find mk fixed point","categories":["cs"],"tags":["plt","utlc","fixed point"]},"fields":{"slug":"/blog/2020/07/27/cs/how-to-find-mk-fixed-point/"}}},{"node":{"id":"546863be-ba1c-595e-8370-eb774f31f60c","frontmatter":{"title":"lexer 原理解釋","categories":["cs"],"tags":["compiler","lexer","golang"]},"fields":{"slug":"/blog/2017/07/08/cs/lexer-explains/"}}},{"node":{"id":"e507df39-a49c-5c75-a4c4-507de675ce52","frontmatter":{"title":"ANTLR v4--introduction","categories":["cs"],"tags":["antlr4"]},"fields":{"slug":"/blog/2017/09/03/cs/introduction-of-antlr4/"}}},{"node":{"id":"5072ada0-29d8-500b-8371-f80533ab27b0","frontmatter":{"title":"Vim replace","categories":["cs"],"tags":["vim"]},"fields":{"slug":"/blog/2017/10/24/cs/vim-replace/"}}},{"node":{"id":"e34022aa-be3f-504a-9cc9-b222c3b6e52b","frontmatter":{"title":"Type driven development in C++","categories":["cs"],"tags":["cpp"]},"fields":{"slug":"/blog/2017/12/23/cs/type-driven-development-in-cpp/"}}},{"node":{"id":"d191956f-b5bb-5c3f-993a-eacec934f193","frontmatter":{"title":"llvm Go bindings","categories":["cs"],"tags":["llvm","golang"]},"fields":{"slug":"/blog/2017/12/04/cs/llvm-go-bindings/"}}},{"node":{"id":"28754ab9-bc87-5304-83d9-11586ee70fce","frontmatter":{"title":"C++ thread 基礎","categories":["cs"],"tags":["cpp","thread"]},"fields":{"slug":"/blog/2017/06/26/cs/cpp-thread-basic/"}}},{"node":{"id":"fd161ad4-402d-58bd-8190-08e44075694a","frontmatter":{"title":"Erlang Quick Start","categories":["cs"],"tags":["erlang"]},"fields":{"slug":"/blog/2018/01/05/cs/erlang-quick-start/"}}},{"node":{"id":"44c9e7e4-a19a-5f18-98f6-b6105e3ceb1c","frontmatter":{"title":"The best practice of Singleton in Golang","categories":["cs"],"tags":["golang","DesignPattern"]},"fields":{"slug":"/blog/2018/02/12/cs/singleton-best-practice-in-golang/"}}},{"node":{"id":"6cf1b36b-fed7-5566-84f6-64f596c0568f","frontmatter":{"title":"OpenCV introduction","categories":["cs"],"tags":["OpenCV","cpp"]},"fields":{"slug":"/blog/2018/02/08/cs/opencv-introduction/"}}},{"node":{"id":"08473604-caaf-538c-a9ac-633842a5eb3a","frontmatter":{"title":"You should know about `this`","categories":["cs"],"tags":["javascript"]},"fields":{"slug":"/blog/2018/02/09/cs/you-should-know-about-this/"}}},{"node":{"id":"a379d931-4a5a-50cf-b87a-29c36bf0bfca","frontmatter":{"title":"Sort by interface in Go","categories":["cs"],"tags":["golang"]},"fields":{"slug":"/blog/2018/02/14/cs/sort-by-interface-in-go/"}}},{"node":{"id":"7aadac41-a6ef-595c-adb3-fe7349045f54","frontmatter":{"title":"How to disable Go test caching","categories":["cs"],"tags":["golang"]},"fields":{"slug":"/blog/2018/03/17/cs/how-to-disable-go-test-caching/"}}},{"node":{"id":"b22b2e98-3a62-5e3a-b698-5b6521ea8c3f","frontmatter":{"title":"Introduction Of Char Recognizing -- Lexer Tech","categories":["cs"],"tags":["compiler","lexer","rust"]},"fields":{"slug":"/blog/2018/02/25/cs/introduction-of-char-recognizing-lexer-tech/"}}},{"node":{"id":"843f70c9-b9bc-52c0-920f-8ebec90635fe","frontmatter":{"title":"Create a WaitGroup by yourself","categories":["cs"],"tags":["golang","concurrency"]},"fields":{"slug":"/blog/2018/02/15/cs/create-a-wait-group-by-yourself-and-do-not-use-it/"}}},{"node":{"id":"49fd1e2e-1554-5d24-ae01-66e647e77df8","frontmatter":{"title":"Phoneix 安裝與啟動","categories":["cs"],"tags":["phoenix","elixir","web"]},"fields":{"slug":"/blog/2018/03/31/cs/phoenix-run-and-up/"}}},{"node":{"id":"c16962e8-fa69-54e8-bb2b-c781a2eabd46","frontmatter":{"title":"Nginx 安裝與啟動","categories":["cs"],"tags":["nginx","web"]},"fields":{"slug":"/blog/2018/04/02/cs/nginx-run-and-up/"}}},{"node":{"id":"67df5cf3-7b75-52a0-bf1b-0e9a81cb0cb0","frontmatter":{"title":"How to getting start with Rust","categories":["cs"],"tags":["rust"]},"fields":{"slug":"/blog/2018/05/26/cs/getting-start-with-rust/"}}},{"node":{"id":"c1666f78-5ad1-5fcc-9142-1f14a81b6079","frontmatter":{"title":"Go Channels 入門","categories":["cs"],"tags":["golang","concurrency"]},"fields":{"slug":"/blog/2018/04/23/cs/go-channel-introduction/"}}},{"node":{"id":"c8c71a5e-7c2f-5503-b2f1-ac0620db1157","frontmatter":{"title":"Design of Redux-go v2","categories":["cs"],"tags":["golang","redux"]},"fields":{"slug":"/blog/2018/05/17/cs/design-of-redux-go-v2/"}}},{"node":{"id":"765d1f5a-a9e2-5773-b81d-6fa2a465e86b","frontmatter":{"title":"Error is Value","categories":["cs"],"tags":["golang","errors"]},"fields":{"slug":"/blog/2018/06/22/cs/error-is-value/"}}},{"node":{"id":"5d5d1de0-f7e4-50de-a930-599e3cd895b3","frontmatter":{"title":"Some thinking from Elixir X Ruby Conf","categories":["cs"],"tags":["elixir"]},"fields":{"slug":"/blog/2018/05/01/cs/elixir-ruby-conf-2018-thinking/"}}},{"node":{"id":"ec13d746-3be7-5ec5-8cc2-9f5773c784ee","frontmatter":{"title":"Practical issue about DNS -- EDNS0","categories":["cs"],"tags":["networking","dns","golang"]},"fields":{"slug":"/blog/2018/08/07/cs/practical-issue-about-dns-edns0/"}}},{"node":{"id":"d6e6b1cc-7b50-59af-b3dd-1e2d1bd5fb5e","frontmatter":{"title":"Reflection in Go: create a stack[T]","categories":["cs"],"tags":["golang","reflection"]},"fields":{"slug":"/blog/2018/07/22/cs/reflection-in-go-create-a-stack-t/"}}},{"node":{"id":"a82969d9-e24d-5361-8fdf-797bd2415044","frontmatter":{"title":"gRPC quick start in Go","categories":["cs"],"tags":["networking","gRPC","golang"]},"fields":{"slug":"/blog/2018/08/16/cs/gRPC-basic-tutorial/"}}},{"node":{"id":"03ff243a-28ff-5c17-93bc-5acbf8aa87df","frontmatter":{"title":"Mark Sweep GC","categories":["cs"],"tags":["gc"]},"fields":{"slug":"/blog/2018/09/03/cs/mark-sweep/"}}},{"node":{"id":"b2e1114a-0574-582d-801f-ea4a99e96feb","frontmatter":{"title":"Use httpexpect to test server","categories":["cs"],"tags":["http","testing","networking","golang"]},"fields":{"slug":"/blog/2018/09/16/cs/httpexpect-go/"}}},{"node":{"id":"30f863fb-545c-5fdf-8fbe-bf908eb73753","frontmatter":{"title":"Go quick start","categories":["cs"],"tags":["golang"]},"fields":{"slug":"/blog/2018/09/23/cs/golang-quick-start/"}}},{"node":{"id":"9fd83d10-85ca-5ed3-9416-599e3d54d4c6","frontmatter":{"title":"Kubernetes 從 Pod 開始","categories":["cs"],"tags":["kubernetes"]},"fields":{"slug":"/blog/2018/10/27/cs/kubernetes-start-from-pod/"}}},{"node":{"id":"2d6b2494-ee64-5f20-a82a-f73f14882cee","frontmatter":{"title":"fun networking: tcp close","categories":["cs"],"tags":["workrecord","networking","tcp"]},"fields":{"slug":"/blog/2018/11/30/cs/fun-network-tcp-close/"}}},{"node":{"id":"b69e04f4-45ce-5dff-9a51-3fd54d7f2136","frontmatter":{"title":"XDP some note","categories":["cs"],"tags":["networking","xdp"]},"fields":{"slug":"/blog/2018/11/30/cs/xdp-some-note/"}}},{"node":{"id":"292b53ea-c5a7-551b-8607-b920c50d4c6e","frontmatter":{"title":"Test LLVM Go binding in travis","categories":["cs"],"tags":["llvm","golang","testing","travis"]},"fields":{"slug":"/blog/2018/10/06/cs/test-llvm-go-binding-in-travis/"}}},{"node":{"id":"092c8346-aeb9-5615-9d86-7d331ef2cace","frontmatter":{"title":"Kubernetes context","categories":["cs"],"tags":["kubernetes"]},"fields":{"slug":"/blog/2018/12/09/cs/kubernetes-context/"}}},{"node":{"id":"948da191-2170-532c-9e7a-61104f546f7a","frontmatter":{"title":"Testing in Go","categories":["cs"],"tags":["golang","testing","debug"]},"fields":{"slug":"/blog/2018/11/17/cs/testing-in-go/"}}},{"node":{"id":"6759bad6-0b3f-5a19-b865-ee89d50703b4","frontmatter":{"title":"Magic in redux-go v2.1: package rematch","categories":["cs"],"tags":["golang","redux"]},"fields":{"slug":"/blog/2018/07/04/cs/magic-in-redux-go-2.1/"}}},{"node":{"id":"f1b55b8d-f933-5627-8717-d62ef5dbe2f8","frontmatter":{"title":"戴德金分割與1為何等於0.9...(無限循環)","categories":["math"],"tags":["dedekind","dedekind cut"]},"fields":{"slug":"/blog/2019/03/01/math/dedekind-cut-and-application/"}}},{"node":{"id":"8de033ca-f3ad-5b21-b998-6f31085d5c9e","frontmatter":{"title":"Should I learn?","categories":["cs"],"tags":["career","life"]},"fields":{"slug":"/blog/2018/12/22/cs/should-i-learn/"}}},{"node":{"id":"cee81faa-22ef-5571-8540-e84fbfd9f710","frontmatter":{"title":"How to compare Go benchmark in TravisCI","categories":["cs"],"tags":["golang","testing","travis"]},"fields":{"slug":"/blog/2018/12/28/cs/golang-benchmark-compare/"}}},{"node":{"id":"05bd5f1b-bc76-5625-a764-e0d3c71b402f","frontmatter":{"title":"Make googletest-like test framework from scratch","categories":["cs"],"tags":["metaprogramming","cpp"]},"fields":{"slug":"/blog/2019/03/03/cs/make-googletest-like-test-framework-from-scratch/"}}},{"node":{"id":"0644a550-53f6-545c-9659-35a85d899494","frontmatter":{"title":"Introduction of LLDB","categories":["cs"],"tags":["tool","debugger","lldb"]},"fields":{"slug":"/blog/2019/03/17/cs/introduction-of-lldb/"}}},{"node":{"id":"9a3c9420-dd65-579b-bbe6-04cdd5654b91","frontmatter":{"title":"Write a hashmap in Go","categories":["cs"],"tags":["data-structure","golang"]},"fields":{"slug":"/blog/2019/04/04/cs/write-hashmap-in-go/"}}},{"node":{"id":"58d36ae9-d194-5fac-bc24-d0c9730866bf","frontmatter":{"title":"5 tools for file transfer","categories":["cs"],"tags":["tool"]},"fields":{"slug":"/blog/2019/04/27/cs/five-tools-for-file-transfer/"}}},{"node":{"id":"fd5f04d7-405c-5e7d-8ab6-3ccdc0bce760","frontmatter":{"title":"HugePages on Kubernetes","categories":["cs"],"tags":["workrecord","hugepages","kubernetes","linux"]},"fields":{"slug":"/blog/2019/05/04/cs/hugepages-on-kubernetes/"}}},{"node":{"id":"7755f76a-3458-5764-9f50-68c4ffb0a6c9","frontmatter":{"title":"gRPC proxy: approach & pain","categories":["cs"],"tags":["gRPC"]},"fields":{"slug":"/blog/2019/04/13/cs/grpc-proxy-approach-and-pain/"}}},{"node":{"id":"a74742e1-23ff-5977-bdfc-5f74842b234c","frontmatter":{"title":"A simple way to ensure interface won't be implemented accidently","categories":["cs"],"tags":["golang"]},"fields":{"slug":"/blog/2019/06/18/cs/simple-way-to-ensure-go-interface-wont-be-implement-accidently/"}}},{"node":{"id":"9c683f4e-7281-5153-a08a-a50b6ee05b88","frontmatter":{"title":"The Go concurrency bug I made","categories":["cs"],"tags":["golang","concurrency","workrecord"]},"fields":{"slug":"/blog/2019/05/25/cs/golang-concurrency-bug-i-made/"}}},{"node":{"id":"49d97e32-8a97-5e60-8c30-c78c403bba0d","frontmatter":{"title":"tcpdump cheat sheet","categories":["cs"],"tags":["tcpdump","networking"]},"fields":{"slug":"/blog/2019/06/25/cs/tcpdump-cheat-sheet/"}}},{"node":{"id":"bbf87cca-106e-5d96-a27d-a4f68a7cf012","frontmatter":{"title":"How trait with lifetime can be a trouble and how to fix it","categories":["cs"],"tags":["rust","rust lifetime"]},"fields":{"slug":"/blog/2019/07/31/cs/how-lifetime-trait-can-be-trouble-and-how-to-fix-it/"}}},{"node":{"id":"739889c2-58d8-5632-9bc4-1518751e52a6","frontmatter":{"title":"Notes: Ruby Conf Taiwan 2019","categories":["cs"],"tags":["language","gc"]},"fields":{"slug":"/blog/2019/08/13/cs/ruby-conf-taiwan-2019/"}}},{"node":{"id":"ad56e808-8f85-55ad-9aa7-34f5336e6d4a","frontmatter":{"title":"Privileged Pod -- Debug kubernetes node","categories":["cs"],"tags":["kubernetes","debug"]},"fields":{"slug":"/blog/2019/09/01/cs/privileged-pod/"}}},{"node":{"id":"4e62b250-d25f-5c39-bd18-2d5b3514461b","frontmatter":{"title":"cgo can be a trouble","categories":["cs"],"tags":["golang","cgo"]},"fields":{"slug":"/blog/2019/08/15/cs/cgo-can-be-a-trouble/"}}},{"node":{"id":"c21bfb9e-3ed2-5312-8652-c28945f78f52","frontmatter":{"title":"Why not a big script","categories":["cs"],"tags":["shell"]},"fields":{"slug":"/blog/2019/10/05/cs/why-not-big-script/"}}},{"node":{"id":"10eb1882-d25b-532e-90b3-ba31c0ae4de0","frontmatter":{"title":"nix report","categories":["cs"],"tags":["nix","shell"]},"fields":{"slug":"/blog/2019/09/12/cs/nix-report/"}}},{"node":{"id":"778b403e-0913-55b6-8631-8f709c3190a4","frontmatter":{"title":"DPDK -- EAL Input/output error","categories":["cs"],"tags":["dpdk","networking","workrecord"]},"fields":{"slug":"/blog/2019/10/18/cs/dpdk-input-output-error/"}}},{"node":{"id":"d1844995-f98a-582d-8034-1261c2538134","frontmatter":{"title":"How to use .gitignore","categories":["cs"],"tags":["git"]},"fields":{"slug":"/blog/2019/11/08/cs/how-to-use-gitignore/"}}},{"node":{"id":"af72f2b3-cd09-547a-bce0-9cfef54189d7","frontmatter":{"title":"DPDK usertools: devbind","categories":["cs"],"tags":["dpdk","networking","workrecord"]},"fields":{"slug":"/blog/2019/10/19/cs/dpdk-usertools-devbind/"}}},{"node":{"id":"55cd1966-fe9a-5d8e-a7bc-613b82ea53cc","frontmatter":{"title":"Weird behavior in Go: encoding/gob","categories":["cs"],"tags":["gob","golang","workrecord"]},"fields":{"slug":"/blog/2019/10/31/cs/weird-behavior-gob/"}}},{"node":{"id":"95cd04e7-3518-5f09-bc15-b481e5502ab8","frontmatter":{"title":"Algebra data type vs Class","categories":["cs"],"tags":["plt","scala","haskell"]},"fields":{"slug":"/blog/2019/11/19/cs/algebra-data-type-vs-class/"}}},{"node":{"id":"e7effcba-43fa-55a2-a9a4-3ae56227bb4d","frontmatter":{"title":"Reflection on Working effectively with legacy code --- Part I","categories":["cs"],"tags":["programming","testing"]},"fields":{"slug":"/blog/2019/11/24/cs/reflection-on-working-effectively-with-legacy-code-part-one/"}}},{"node":{"id":"9f3948b2-bb63-5a4f-9c9c-0a1fadfc3517","frontmatter":{"title":"Mergeable replicated data types","categories":["cs"],"tags":["paper","data-structure"]},"fields":{"slug":"/blog/2019/11/30/cs/mergeable-replicated-data-types/"}}},{"node":{"id":"f12f1f8a-6de2-51da-8f8a-d323a92b3549","frontmatter":{"title":"Infinite Type","categories":["cs"],"tags":["plt","language"]},"fields":{"slug":"/blog/2019/12/08/cs/infinite-type/"}}},{"node":{"id":"a2137fb4-59cf-577d-b07f-a829d4f6882c","frontmatter":{"title":"How to test in Haskell: HSpec setup","categories":["cs"],"tags":["haskell","beginner","testing"]},"fields":{"slug":"/blog/2019/12/14/cs/how-to-test-haskell/"}}},{"node":{"id":"5e569bcc-7ad2-5200-921e-a0ce3b17a773","frontmatter":{"title":"NOTE: If we write kubernetes client in Rust","categories":["cs"],"tags":["note","programming","kubernetes","rust"]},"fields":{"slug":"/blog/2019/12/13/cs/if-write-kube-client-go-in-rust/"}}},{"node":{"id":"06cc88f1-000b-506b-8afb-0ba5409f5da1","frontmatter":{"title":"Haskell quick start","categories":["cs"],"tags":["haskell","beginner","plt","language"]},"fields":{"slug":"/blog/2019/12/08/cs/haskell-quick-start/"}}},{"node":{"id":"785de266-a84d-57e3-b119-46a5f7e0114a","frontmatter":{"title":"NOTE: get labels from Pod","categories":["cs"],"tags":["note","kubernetes"]},"fields":{"slug":"/blog/2019/12/20/cs/note-get-labels-from-pod/"}}},{"node":{"id":"846c66d5-4f4a-5544-9491-fdc1671be380","frontmatter":{"title":"From Infinite Type to Functor","categories":["cs"],"tags":["plt","functor","language","haskell"]},"fields":{"slug":"/blog/2019/12/13/cs/from-infinite-type-to-functor/"}}},{"node":{"id":"d4e2efd2-4da2-54dd-9e46-544abf0f1953","frontmatter":{"title":"NOTE: What is lambda calculus","categories":["cs"],"tags":["note","plt","utlc"]},"fields":{"slug":"/blog/2020/01/01/cs/note-what-is-lambda-calculus/"}}},{"node":{"id":"0bbd48f9-b7ac-5fbe-85f5-19ca3fa12734","frontmatter":{"title":"Type as Constraint: Why we need more type?","categories":["cs"],"tags":["plt","language"]},"fields":{"slug":"/blog/2020/01/16/cs/type-as-constraint-why-we-need-more-type/"}}},{"node":{"id":"bce44484-82be-5531-bbc8-a9e1bc59076c","frontmatter":{"title":"Reflection on Working effectively with legacy code --- chapter 11 to 19","categories":["cs"],"tags":["programming","testing"]},"fields":{"slug":"/blog/2020/01/03/cs/reflection-on-working-effectively-with-legacy-code-ch-11-19/"}}},{"node":{"id":"d74e85e7-1028-51d0-add9-0c0ea37c4cb6","frontmatter":{"title":"TDD is not silver bullet","categories":["cs"],"tags":["programming"]},"fields":{"slug":"/blog/2020/01/11/cs/tdd-is-not-silver-bullet/"}}},{"node":{"id":"de3bd99a-2f0c-5473-a853-21523d01dbb5","frontmatter":{"title":"Reflection on Working effectively with legacy code --- chapter 20 to 23","categories":["cs"],"tags":["programming","testing"]},"fields":{"slug":"/blog/2020/01/04/cs/reflection-on-working-effectively-with-legacy-code-ch-20-23/"}}},{"node":{"id":"44eb6dda-c3e9-54fb-a251-b415fb08b49f","frontmatter":{"title":"NOTE: a little bit Z3 solver","categories":["cs"],"tags":["note","smt","z3"]},"fields":{"slug":"/blog/2020/01/24/cs/note-a-little-bit-z3-solver/"}}},{"node":{"id":"f4cd1802-ad9e-5d80-81f0-79f85515f2cd","frontmatter":{"title":"NOTE: bounded polymorphism","categories":["cs"],"tags":["note","plt","language","haskell"]},"fields":{"slug":"/blog/2020/01/24/cs/note-bound-polymorphism/"}}},{"node":{"id":"2a3dbf6d-50c5-5b0e-b4c2-4890cfc650a0","frontmatter":{"title":"NOTE: C++ optional","categories":["cs"],"tags":["note","cpp","language"]},"fields":{"slug":"/blog/2020/01/26/cs/note-cpp-optional/"}}},{"node":{"id":"ec5fd544-7096-5098-89a6-0f06a873d47e","frontmatter":{"title":"不會騎 Gogoro 的兩個鄉巴佬","categories":["funny"],"tags":["life"]},"fields":{"slug":"/blog/2020/01/31/funny/two-idiots-who-cant-ride-gogoro/"}}},{"node":{"id":"e5f1b03a-f5cd-5b9b-aa1f-499ea2076fac","frontmatter":{"title":"一些推薦去嘗試看看的程式語言","categories":["cs"],"tags":["language"]},"fields":{"slug":"/blog/2020/02/06/cs/suggested-languages/"}}},{"node":{"id":"10e9c6f2-3474-5ebc-99d2-5c4a97f879ea","frontmatter":{"title":"Binary Encoding of Integer","categories":["cs"],"tags":["fundamental"]},"fields":{"slug":"/blog/2020/03/21/cs/binary-encoding-of-interger/"}}},{"node":{"id":"e2302e39-eea1-5df3-90a6-ef060120cf9e","frontmatter":{"title":"小說推薦：天防者","categories":["book"],"tags":["novel","recommend","skyward","Brandon Sanderson"]},"fields":{"slug":"/blog/2020/04/01/book/recommend-novel-skyward/"}}},{"node":{"id":"ed391a8d-358b-56e3-b55c-f0fd90492aa8","frontmatter":{"title":"NOTE: Seven Bridges of Königsberg and Eulerian graph","categories":["math"],"tags":["note","topology","graph","Eulerian path","Eulerian circuit"]},"fields":{"slug":"/blog/2020/04/03/math/note-seven-bridges-of-konigsberg-eulerian-path/"}}},{"node":{"id":"80d44a1a-1a60-5d93-bf71-d21cbe6d796c","frontmatter":{"title":"NOTE: class member initialization order in C++","categories":["cs"],"tags":["note","cpp","class member","initialization","language"]},"fields":{"slug":"/blog/2020/04/13/cs/note-cpp-member-initialize-order/"}}},{"node":{"id":"757f6fbc-6d36-5b3f-989e-ef792d13aa7e","frontmatter":{"title":"NOTE: simply typed lambda calculus","categories":["cs"],"tags":["note","plt","stlc"]},"fields":{"slug":"/blog/2020/03/08/cs/note-stlc/"}}},{"node":{"id":"047ac64e-b55c-5043-adae-1d5c9321c5cd","frontmatter":{"title":"NOTE: how to install Nix package manager on MacOS Catalina","categories":["cs"],"tags":["note","nix","macos","catalina"]},"fields":{"slug":"/blog/2020/04/17/cs/note-how-to-install-nix-on-macos-catalina/"}}},{"node":{"id":"bc080f44-1eaf-5efd-a61a-ff3f1da28b84","frontmatter":{"title":"From Functor to Applicative","categories":["cs"],"tags":["plt","applicative","language","haskell"]},"fields":{"slug":"/blog/2020/04/11/cs/from-functor-to-applicative/"}}},{"node":{"id":"c6c52b5a-8170-508f-b887-6b1ce2f6ecda","frontmatter":{"title":"How to parse expression with the parser combinator","categories":["cs"],"tags":["compiler","parser","racket"]},"fields":{"slug":"/blog/2020/05/03/cs/how-to-parse-expression-with-parser-combinator/"}}},{"node":{"id":"eff65ed1-fdb8-5069-919f-3983784e1344","frontmatter":{"title":"A beautiful proof: There have infinite primes","categories":["math"],"tags":["prime"]},"fields":{"slug":"/blog/2020/05/09/math/a-beautiful-proof-there-have-infinite-primes/"}}},{"node":{"id":"a30fc310-d412-5f36-95c3-0aee1ea000ae","frontmatter":{"title":"奶油白醬義大利麵","categories":["recipe"],"tags":["spaghetti","white sauce"]},"fields":{"slug":"/blog/2020/05/10/recipe/spaghetti/"}}},{"node":{"id":"0ad29589-2261-5f8f-a0f6-0ef61d5a4833","frontmatter":{"title":"NOTE: 演算法的各種時間複雜度","categories":["cs"],"tags":["note","algorithm","time complexity"]},"fields":{"slug":"/blog/2020/05/12/cs/algorithm-time-complexity/"}}},{"node":{"id":"4bc528e2-46d3-5ff9-9ef6-cd2036d9d741","frontmatter":{"title":"NOTE: 樸素集合論三大悖論","categories":["math"],"tags":["note","set theory","paradox","type theory"]},"fields":{"slug":"/blog/2020/05/31/math/set-theory-three-paradox/"}}},{"node":{"id":"67ccc98d-872a-548d-bec9-c1edd2297252","frontmatter":{"title":"Currying","categories":["cs"],"tags":["racket","macro"]},"fields":{"slug":"/blog/2020/05/31/cs/currying/"}}},{"node":{"id":"d29c9aa1-2b7f-531a-868a-ccdca6371411","frontmatter":{"title":"De Bruijn index: why and how","categories":["cs"],"tags":["plt","de bruijn index","racket"]},"fields":{"slug":"/blog/2020/05/16/cs/de-bruijn-index/"}}},{"node":{"id":"203837be-04fc-567d-9450-33a3f6b02872","frontmatter":{"title":"NOTE: ZFC","categories":["math"],"tags":["note","set theory"]},"fields":{"slug":"/blog/2020/06/11/math/note-zfc/"}}},{"node":{"id":"29b4fcc7-cbe5-57fd-a9c5-7a18c62d8ee6","frontmatter":{"title":"正確實作 substitution 有多難","categories":["cs"],"tags":["plt","utlc"]},"fields":{"slug":"/blog/2020/06/04/cs/how-hard-can-implement-substitution-correctly-be/"}}},{"node":{"id":"c6c0c8c1-db91-54c9-8929-78658c2a90dd","frontmatter":{"title":"NOTE: lambda 2","categories":["cs"],"tags":["note","plt","lambda 2"]},"fields":{"slug":"/blog/2020/06/12/cs/second-order-typed-lambda-calculus/"}}},{"node":{"id":"f49e05b7-906e-5dca-87d5-2a3d39e773db","frontmatter":{"title":"大阪燒","categories":["recipe"],"tags":["okonomiyaki"]},"fields":{"slug":"/blog/2020/06/17/recipe/recipe-okonomiyaki/"}}},{"node":{"id":"b8aae0b8-d789-57eb-b671-75bfa2f4290d","frontmatter":{"title":"NOTE: 演算法的量級","categories":["cs"],"tags":["note","algorithm","order"]},"fields":{"slug":"/blog/2020/06/20/cs/algorithm-order/"}}},{"node":{"id":"a3447c9d-20fc-58e9-a993-f25b1f2b0d8a","frontmatter":{"title":"Extension hack","categories":["cs"],"tags":["swift","extension"]},"fields":{"slug":"/blog/2017/09/29/cs/extension-hack/"}}},{"node":{"id":"8dce6fe3-902a-5b3d-9d14-2e302cf0bef5","frontmatter":{"title":"小說推薦：優質國度","categories":["book"],"tags":["novel","recommend","Quality Land"]},"fields":{"slug":"/blog/2020/07/03/book/recommend-novel-quality-land/"}}},{"node":{"id":"3c3130a0-7b7a-5b3f-9f3c-9a23ed88cc72","frontmatter":{"title":"Swift --extension概念入門","categories":["cs"],"tags":["swift","extension"]},"fields":{"slug":"/blog/2017/09/29/cs/swift-extension/"}}},{"node":{"id":"97bb49ed-2ce6-588c-bd14-86dcecaa2116","frontmatter":{"title":"NOTE: Algebra Structure","categories":["math"],"tags":["note","algebra structure","magma","semigroup","monoid","group"]},"fields":{"slug":"/blog/2020/07/12/math/algebra-structure/"}}},{"node":{"id":"ab571f39-a304-515c-9e56-c4bdc3a1d70b","frontmatter":{"title":"Why Logic Programming?","categories":["cs"],"tags":["logic programming","racket","rosette","datalog"]},"fields":{"slug":"/blog/2020/07/15/cs/why-logic-programming/"}}},{"node":{"id":"13404fcc-084f-5f56-8938-c72eb8e96c94","frontmatter":{"title":"Tracing source code of Kubernetes client-go","categories":["cs"],"tags":["kubernetes","golang"]},"fields":{"slug":"/blog/2019/01/25/cs/kube-client-go-source-code-tracing/"}}},{"node":{"id":"602307b1-7619-55ee-91f4-b488361ff1fd","frontmatter":{"title":"程式設計思考（一）核心領域","categories":["cs"],"tags":["programming","beginner","racket"]},"fields":{"slug":"/blog/2019/11/09/cs/abstraction-of-programming-design/"}}},{"node":{"id":"b88e5107-daac-51de-aace-b9d13d01c5d1","frontmatter":{"title":"Reflection on Working effectively with legacy code --- chapter 6 to 10","categories":["cs"],"tags":["programming","testing"]},"fields":{"slug":"/blog/2019/12/07/cs/reflection-on-working-effectively-with-legacy-code-ch-6-10/"}}},{"node":{"id":"45c7c10b-ebe7-5f8a-9bb8-8384c90744cf","frontmatter":{"title":"Interaction with C in Zig","categories":["cs"],"tags":["zig","c","language"]},"fields":{"slug":"/blog/2019/12/22/cs/interaction-with-c-in-zig/"}}},{"node":{"id":"24cddb21-779c-545e-aff0-dd840418c8d2","frontmatter":{"title":"最後一次抱怨 Go","categories":["cs"],"tags":["golang","language"]},"fields":{"slug":"/blog/2020/01/19/cs/last-time-complain-about-go/"}}},{"node":{"id":"460001d0-2e11-586f-a331-e7294c963060","frontmatter":{"title":"A Racket macro tutorial -- get HTTP parameters easier","categories":["cs"],"tags":["racket","metaprogramming","macro"]},"fields":{"slug":"/blog/2020/02/16/cs/a-racket-macro-tutorial-get-http-parameters-easier/"}}},{"node":{"id":"d0e1e323-7ade-5a75-8c86-dbfd7f94861b","frontmatter":{"title":"Programming 生涯回顧","categories":["cs"],"tags":["career","life"]},"fields":{"slug":"/blog/2020/05/13/cs/programming-life-retro/"}}},{"node":{"id":"2a45e9d5-898d-59d4-84d4-f96458edfd2e","frontmatter":{"title":"程式設計思考（二）操作介面","categories":["cs"],"tags":["programming","beginner","racket"]},"fields":{"slug":"/blog/2020/04/25/cs/abstraction-of-programming-design-2-user-interface/"}}},{"node":{"id":"c029b0a3-b626-5758-b8e5-b6a38c781376","frontmatter":{"title":"Kubernetes Networking: concept and overview from underlying perspective","categories":["cs"],"tags":["networking","kubernetes","linux"]},"fields":{"slug":"/blog/2019/05/18/cs/kubernetes-networking-concept-and-overview/"}}},{"node":{"id":"b9b6191e-1aa2-557b-9cbc-fcf4f689fe93","frontmatter":{"title":"Hindley-Milner type system: Incrementally build way & Make new language in Racket","categories":["cs"],"tags":["plt","hindley milner","racket"]},"fields":{"slug":"/blog/2020/05/24/cs/hindley-milner-system-incremental-build-and-make-new-language/"}}}]}},"pageContext":{"slug":"/blog/2020/05/24/cs/hindley-milner-system-incremental-build-and-make-new-language/"}}}