{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2020/05/03/cs/how-to-parse-expression-with-parser-combinator/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>Writing parser is a boring and massive job, therefore, people create many ways like parser generators to reduce costs. One of them called parser combinator, parser combinator solves two problems: 1. didn't massive as the hand-crafted parser, 2. didn't impossible to debug like parser generator. Well, it sounds perfect, doesn't it? A parser combinator is great, but one thing could be a problem: precedence descent parser. Unlike parser generator usually provided builtin supporting for operators' precedence. Parser combinator usually only provided basic support for sequence and selective parsing. You probably already heard about <a href=\"https://en.wikipedia.org/wiki/Operator-precedence_parser\">operator precedence parser</a>, let's first take a look at its pseudo code(provided by Wiki):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">parse_expression()\n    return parse_expression_1(parse_primary(), 0)\nparse_expression_1(lhs, min_precedence)\n    lookahead := peek next token\n    while lookahead is a binary operator whose precedence is &gt;= min_precedence\n        op := lookahead\n        advance to next token\n        rhs := parse_primary ()\n        lookahead := peek next token\n        while lookahead is a binary operator whose precedence is greater\n                 than op&#39;s, or a right-associative operator\n                 whose precedence is equal to op&#39;s\n            rhs := parse_expression_1 (rhs, lookahead&#39;s precedence)\n            lookahead := peek next token\n        lhs := the result of applying op with operands lhs and rhs\n    return lhs</code></pre></div>\n<p>Unfortunately, this is not suitable to port on to a parser based on combinator, because figure out how to introduce state monad into parser monad is a complex job, but that would not be a problem since we have a more intuitive solution which starts from avoiding the left recursion. If you have ever taken a compiler class and it, unfortunately, spend most of the time on parsing, then you may be heard <a href=\"https://en.wikipedia.org/wiki/Left_recursion\">left recursion</a>:</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">A \\rightarrow A \\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>\n<p>Where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span> is any sequence of terminal and non-terminal symbols. For example:</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>→</mo><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>+</mo><mi>T</mi><mi>e</mi><mi>r</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">Expression \\rightarrow Expression + Term</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">m</span></span></span></span></span>\n<p>A naive implementation would loop on <code class=\"language-text\">expression()</code> forever. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang racket\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">expression</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">expression</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">; in Racket, a char `k` express as `#\\k`</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> <span class=\"token character string\">#\\+</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">term</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>To solve this problem, first, we break down syntax:</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>→</mo><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>r</mi><mspace linebreak=\"newline\"></mspace><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mo>→</mo><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mtext>  </mtext><mo>∗</mo><mtext>  </mtext><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mspace linebreak=\"newline\"></mspace><mi>A</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mo>→</mo><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi><mtext>  </mtext><mo>+</mo><mtext>  </mtext><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>E</mi><mi>x</mi><mi>p</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">Factor \\rightarrow Integer \\\\\nMultipleExpr \\rightarrow Factor \\; * \\; Factor \\\\\nAdditionExpr \\rightarrow MultipleExpr \\; + \\; MultipleExpr</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span>\n<p>Then we map them to parser combinators:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\">#lang racket\n\n<span class=\"token punctuation\">(</span><span class=\"token function\">require</span> data/monad data/applicative<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token function\">require</span> megaparsack megaparsack/text<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> lexeme/p\n  <span class=\"token comment\">;;; lexeme would take at least one space or do nothing</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">do</span> <span class=\"token punctuation\">(</span><span class=\"token function\">or/p</span> <span class=\"token punctuation\">(</span><span class=\"token function\">many+/p</span> space/p<span class=\"token punctuation\">)</span> void/p<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">pure</span> <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token string\">'lexeme</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">op/p</span> op-list<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">or/p</span> <span class=\"token punctuation\">(</span><span class=\"token function\">one-of/p</span> op-list<span class=\"token punctuation\">)</span>\n        void/p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> factor/p\n  <span class=\"token punctuation\">(</span><span class=\"token function\">do</span> [expr &lt;- integer/p]\n    <span class=\"token punctuation\">(</span><span class=\"token function\">lexeme/p</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">(</span><span class=\"token function\">pure</span> expr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">binary/p</span> high-level/p op-list<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token function\">do</span> [e &lt;- high-level/p]\n    <span class=\"token comment\">; `es` parse operator then high-level unit, for example, `* 1`.</span>\n    <span class=\"token comment\">; therefore, this parser would stop when the operator is not expected(aka. operator is in op-list)</span>\n    <span class=\"token comment\">; rely on this fact we can leave this loop</span>\n    [es &lt;- <span class=\"token punctuation\">(</span><span class=\"token function\">many/p</span> <span class=\"token punctuation\">(</span><span class=\"token function\">do</span> [op &lt;- <span class=\"token punctuation\">(</span><span class=\"token function\">op/p</span> op-list<span class=\"token punctuation\">)</span>]\n                     <span class=\"token punctuation\">(</span><span class=\"token function\">lexeme/p</span><span class=\"token punctuation\">)</span>\n                     [e &lt;- high-level/p]\n                     <span class=\"token punctuation\">(</span><span class=\"token function\">pure</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> op e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>]\n    <span class=\"token punctuation\">(</span><span class=\"token function\">pure</span> <span class=\"token punctuation\">(</span><span class=\"token function\">foldl</span>\n           <span class=\"token punctuation\">(</span><span class=\"token function\">λ</span> <span class=\"token punctuation\">(</span><span class=\"token function\">op+rhs</span> lhs<span class=\"token punctuation\">)</span>\n             <span class=\"token punctuation\">(</span><span class=\"token function\">match</span> op+rhs\n               [<span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> op rhs<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span> op lhs rhs<span class=\"token punctuation\">)</span>]<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n           e es<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> mul:div/p\n  <span class=\"token punctuation\">(</span><span class=\"token function\">binary/p</span> factor/p <span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token character string\">#\\*</span> <span class=\"token character string\">#\\/</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> add:sub/p\n  <span class=\"token punctuation\">(</span><span class=\"token function\">binary/p</span> mul:div/p <span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token character string\">#\\+</span> <span class=\"token character string\">#\\-</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> expr/p add:sub/p<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Let's check its result: <code class=\"language-text\">(parse-string expr/p &quot;1 + 2 * 3 / 4 - 5&quot;)</code> generate: <code class=\"language-text\">(success &#39;(#\\- (#\\+ 1 (#\\/ (#\\* 2 3) 4)) 5))</code> just as expected. Seems like <code class=\"language-text\">expr/p</code> is our target, but it still is a little massive, doesn't it? We have to modify the definition of each small parser once we need to insert more infix operators. To avoid this, finally going to the purpose of this article, we need an automatic way to do this for us. Observing the definition of parsers, there has a pattern: every infix operator layer can be a <code class=\"language-text\">(binary/p high-level/p op-list)</code>. Using this fact we can create a recursive function:</p>\n<div class=\"gatsby-highlight\" data-language=\"scheme\"><pre class=\"language-scheme\"><code class=\"language-scheme\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> <span class=\"token punctuation\">(</span><span class=\"token function\">table/p</span> base/p list-of-op-list<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">empty?</span> list-of-op-list<span class=\"token punctuation\">)</span>\n      base/p\n      <span class=\"token punctuation\">(</span><span class=\"token function\">table/p</span> <span class=\"token punctuation\">(</span><span class=\"token function\">binary/p</span> base/p <span class=\"token punctuation\">(</span><span class=\"token builtin\">car</span> list-of-op-list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n               <span class=\"token punctuation\">(</span><span class=\"token builtin\">cdr</span> list-of-op-list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">define</span> expr/p\n  <span class=\"token punctuation\">(</span><span class=\"token function\">table/p</span> factor/p\n           <span class=\"token punctuation\">'</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token character string\">#\\*</span> <span class=\"token character string\">#\\/</span><span class=\"token punctuation\">)</span>\n             <span class=\"token punctuation\">(</span><span class=\"token character string\">#\\+</span> <span class=\"token character string\">#\\-</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The function takes a high-level parser and rest list of operator list. Use the head(<code class=\"language-text\">car</code> in Racket) of the list of operator list to create a layer parser via <code class=\"language-text\">binary/p</code>. If the list of operator list hasn't been empty, create more layers via <code class=\"language-text\">table/p</code>. Now we can handle infinite infix operators! Now, is time to take a break and have fun, have a nice day!</p>","frontmatter":{"title":"How to parse expression with the parser combinator","categories":["cs"],"tags":["compiler","parser","racket"]}}},"pageContext":{"slug":"/blog/2020/05/03/cs/how-to-parse-expression-with-parser-combinator/"}}}