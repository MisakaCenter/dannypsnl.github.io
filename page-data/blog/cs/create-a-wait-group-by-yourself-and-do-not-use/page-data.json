{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/create-a-wait-group-by-yourself-and-do-not-use/","result":{"data":{"markdownRemark":{"html":"<p>If you had wrote any concurrency code in Go.\nI think you could seems <code>sync.WaitGroup</code> before.\nAnd today point is focus on create a wait group by channel trick.</p>\n<p>How?</p>\n<p>First you need a channel without buffer.</p>\n<pre><code class=\"language-golang\">func main() {\n    wait := make(chan struct{})\n}\n</code></pre>\n<p>Then get something from it so if there has no value in <code>wait</code>, process keep going.\nBut if just trying to get something from a empty channel. You will get block and cause deadlock.\nThen go will panic it. So we have to change the code a little bit but also be more extendable for next iteration.</p>\n<pre><code class=\"language-golang\">// ...\nn := 0\nwait := make(chan struct{})\n\nfor i := 0; i &#x3C; n; i++ {\n    &#x3C;-wait\n}\n// ...\n</code></pre>\n<p>Now let's create works loop.</p>\n<pre><code class=\"language-golang\">import (\n    \"time\"\n)\n// ...\nn := 10000\nwait := make(chan struct{})\n\nfor i := 0; i &#x3C; n; i++ {\n    time.Sleep(time.Microsecond)\n    wait &#x3C;- struct{}{}\n}\n\nfor i := 0; i &#x3C; n; i++ {\n    &#x3C;-wait\n}\n// ...\n</code></pre>\n<p>ps. These code has a little bug(you can try to find it, or read the answer at the end)</p>\n<p>Now we can see it work. The reason of these code can work is because size n is our expected amount of workers.\nAfter each worker done their jobs. They will send something(here is <code>struct{}{}</code>, but exactly is doesn't matter thing) into our <code>wait</code> channel.\nWe only read <code>n</code> things from <code>wait</code>.</p>\n<p>So after <code>n</code> things be read. We won't be block any more even <code>wait</code> got new thing. Else we have to waiting <code>wait</code>.</p>\n<p>Whole code dependent on this fact.\nHaving these knowledge, we can create ours <code>WaitGroup</code> now.</p>\n<script src=\"https://gist.github.com/dannypsnl/da6eee69239111ef025a6f00bf73faaf.js\"></script>\n<p>As you can see, we use a type wrapping all the thing we need.(It's a basic idiom, so I don't want to say why)</p>\n<p>Then method <code>Add</code> is preparing for <code>n</code> we talk before. Adding these thing in dynamic way.</p>\n<p>Next <code>Done</code> do the thing as we manually do in previous code.</p>\n<p>And <code>Wait</code> is read amount of things equal final <code>n</code>.</p>\n<p>The end let's say what happened in previous code. You should closing the <code>channel</code> always.\nSo the code will be:</p>\n<pre><code class=\"language-golang\">// ...\nwait := make(chan interface{})\ndefer close(wait)\n// ...\n</code></pre>\n<p>Maybe you will feel confusing about this part. The reason is <code>channel</code> won't be collect by GC automatic(if it can, it will be another hell). So always closing it is important.</p>\n<p>ps. In productive code, please still using the <code>sync.WaitGroup</code>, I do a test, <code>sync.WaitGroup</code> is 25% faster than the version you see at here.</p>\n<h3>References:</h3>\n<h4><a href=\"http://www.gopl.io/\">The Go programming language</a></h4>\n<ul>\n<li>Author: Alan A. A. Donovan &#x26; Brian W. Kernighan</li>\n<li>ISBN: 978-986-476-133-3</li>\n</ul>\n<h4><a href=\"http://shop.oreilly.com/product/0636920046189.do\">Concurrency in Go</a></h4>\n<ul>\n<li>Author: Katherine Cox-Buday</li>\n<li>ISBN: 978-1-491-94119-5</li>\n</ul>","frontmatter":{"title":"Create a WaitGroup by yourself"}}},"pageContext":{"slug":"/blog/cs/create-a-wait-group-by-yourself-and-do-not-use/"}}}