{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/golang-quick/","result":{"data":{"markdownRemark":{"html":"<p>I am going to show you enough knowledge to getting start with Go. Are you ready?</p>\n<h2>Variables</h2>\n<p>In Go, we have <code>const</code>, <code>var</code> &#x26; short declaration &#x26; definition.</p>\n<p>In top scope of Go program(out of function)</p>\n<pre><code class=\"language-go\">const C = \"constant\"\nvar   V = \"var\"\n</code></pre>\n<p>We can use a lazy way to do this when we have a lots variables(p.s. <code>var</code> work as <code>const</code>)</p>\n<pre><code class=\"language-go\">const (\n    C  = 1\n    C1 = 2\n    C2 = 3\n)\n</code></pre>\n<p>In <code>func</code>(Go's function keyword), we can have <code>const</code>, <code>var</code> &#x26; short.</p>\n<pre><code class=\"language-go\">func main() {\n    a := 0 // short\n    var b = 1\n    const c = 2\n}\n</code></pre>\n<p>Important thing about short format is it can only have <code>variableName := value</code>, not thing more</p>\n<p>We also can have type after variable name, e.g. <code>var a int = 1</code>.\nBut we usually don't do this.</p>\n<p>An important concept is we can't have any variable is unused in Go.\nThey will cause compile error.</p>\n<h2>Function</h2>\n<p>We use <code>func</code> to start a function definition.</p>\n<pre><code class=\"language-go\">func foo() {}\n</code></pre>\n<p>Format of function define is: <code>func funcName(parameterList) returnType { body }</code></p>\n<p>That's hard to use description to show you how it work, so let's look an example.</p>\n<pre><code class=\"language-go\">func add(lv, rv int) int {\n    return lv + rv\n}\n// Use\na := add(1, 2)\n// a == 3\n</code></pre>\n<p>As you can see, we can omit type if parameter has the same type, we use last one as rest type.</p>\n<p>An important thing is we can return several type at one function.</p>\n<pre><code class=\"language-go\">func Lookup(name string) (age int, error) {\n    age, ok := aMap[name]\n    if !ok {\n        return 0, fmt.Errorf(\"do not have this user: %s\", name)\n    }\n    return age, nil\n}\n</code></pre>\n<p>And here shows an interesting code: <code>age int</code>, yes, we can give return value a name.\nSo that we can assgin value to it &#x26; show what it is.</p>\n<h2>Structure</h2>\n<p>Use a real world example might be better. So here we create a type for user</p>\n<pre><code class=\"language-go\">type User struct {\n    Name string\n    Age  int\n}\n</code></pre>\n<p>So, maybe you already start to think OOP, but not, Go is not an OOP language, why? Let me show you.</p>\n<pre><code class=\"language-go\">func (u *User) SetName(newName string) {\n    u.Name = newName\n}\n\nfunc (u User) GetName() string {\n    return u.Name\n}\n</code></pre>\n<p>This is how we create <code>user.Method()</code> in Go. Focus on <code>receiver</code>(we call <code>u *User</code> this part receiver).\nIn <code>GetName</code>, if you try to modify <code>u.Name</code>, yes, it works, but won't affect the <code>Name</code> of the object you use to call <code>GetName</code>.</p>\n<p>Then why <code>SetName</code> can do that successful? Because it use <strong>pointer receiver</strong>! So now I can tell you, that is just a syntax sugar like:</p>\n<pre><code class=\"language-c\">char* user_get_name(struct user u) {\n  return u.name;\n}\n// In use\nstruct user *u = &#x26;(struct user) {\n  .name = \"Danny\",\n  .age  = 21\n};\nchar* name = user_get_name(*u);\n</code></pre>\n<h2>Collection</h2>\n<p>We all know Go do not have generic, but some times generic is useful, so that's why there has some built-in collection can work with\ndifferent type in Go.</p>\n<ul>\n<li>map</li>\n<li>array/slice</li>\n</ul>\n<p>The map would like:</p>\n<pre><code class=\"language-go\">m := map[string]int {\n    \"Danny\": 21,\n    \"Ben\":   40,\n}\n</code></pre>\n<p>Format is <code>map[type]type</code>, you can pick any type at there.</p>\n<p>Array &#x26; Slice is very similar but different, and that is not my point so I won't talk about that.\nThe format is <code>[]type</code>, as map, you can change type part.</p>\n<h2>Interface</h2>\n<p>Interface is a very important part in Go. Because this model helps us work without inherit system like <code>Java</code> or <code>C++</code>.</p>\n<p>Interface looks like:</p>\n<pre><code class=\"language-go\">type Stringer interface {\n    String() string\n}\n</code></pre>\n<p>We just left a function type at there. Wait, how to use it?\nNo worries, any types own a function <code>String() string</code> is type <code>Stringer</code>.</p>\n<p>That's how it works. So, we even can do this:</p>\n<pre><code class=\"language-go\">type UserDatas map[string]int // map of name to age\nfunc (udatas UserDatas) String() string {\n    // ignore\n}\n</code></pre>\n<h2>Goroutine &#x26; Channel</h2>\n<p>In Go, we use goroutine &#x26; channel control our concurrency system.</p>\n<p>What is goroutine? goroutine is a routine running some task &#x26; be managed by Go runtime.\nHow to create one?</p>\n<pre><code class=\"language-go\">go func() {\n    fmt.Println(\"Hi\")\n}()\n</code></pre>\n<p>We use keyword <code>go</code> with a function call to start one. Who destory it? Go runtime.\nSo that's why we don't need to worry about it's resource.</p>\n<p>But how we get the data after it complete the task?\nThat's why we have <strong>channel</strong>.</p>\n<pre><code class=\"language-go\">// main\nresult := make(chan int)\ngo func() {\n    for i:=0; i&#x3C;10; i++ {\n        result &#x3C;- i*2 // write into channel\n    }\n}()\n// range over channel\nfor elem := range result {\n    fmt.Println(elem)\n}\n</code></pre>\n<p>The flow like:</p>\n<pre><code>main\n | \\\n |  | for 0..9, result &#x3C;- i*2\n | / f1 done\n |\n | read from channel\n |\nmain done\n</code></pre>\n<p>The range over channel &#x26; write into channel is conceptly run at the same time.\nThis is how concurrency looks like in Go.</p>\n<h2>main</h2>\n<p>In Go, an executable required two things.</p>\n<ul>\n<li>In package <code>main</code></li>\n<li><code>func main()</code></li>\n</ul>\n<p>The simplest file is:</p>\n<pre><code class=\"language-go\">package main\n\nfunc main() {}\n</code></pre>\n<h2>package</h2>\n<p>Finally, we talk about package.\nIn Go, package just some files in the same directory with the same package name.\nThen we use environment variable <code>GOPATH</code> to search it.</p>\n<p>So how import looks like?</p>\n<pre><code class=\"language-go\">import \"github.com/dannypsnl/rocket\"\n</code></pre>\n<p>At here, we import the package under <code>$GOPATH/src/github.com/dannypsnl/rocket</code>.\nOf course, we don't have one at there, so now we can execute a command:\n<code>go get ./...</code>.\nThe command will trying to solve dependency we need. So it will download <code>github.com/dannypsnl/rocket</code> into your $GOPATH</p>\n<p>This is the quick start of Go. Thanks for reading, byebye.</p>","frontmatter":{"title":"Go quick start"}}},"pageContext":{"slug":"/blog/cs/golang-quick/"}}}