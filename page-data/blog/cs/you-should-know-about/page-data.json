{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/you-should-know-about/","result":{"data":{"markdownRemark":{"html":"<p><code>this</code> scope rule is one of hardest problem in JS. Let's start it.</p>\n<pre><code class=\"language-js\">function print() {\n  console.log(this.data);\n}\nlet obj = {\n  data: \"This is obj\",\n  print\n};\nobj.print(); // Output: This is obj\n// It's good. But if we send print to other place?\n\nlet printClone = obj.print;\nprintClone(); // Which `this` at here? You have to see `this` of this place then you will know\n// Ok, let me tell you true, you don't know where does the function be send, so you also can't know which this at there.\n// The behavior is totally can not be prediction.\n</code></pre>\n<p>Ok! Now we know the true: <code>this</code> is dynamic. But! We still need to send us function to other place, right? We have to understanding print get the this at <code>obj.print()</code> this expression, not at <code>let obj = { ... }</code> part. Why this is important? Because a lots of novice of JS will write something like this.</p>\n<pre><code class=\"language-js\">// ignore, we are in obj definition\nprint: print.bind(this),\n// ignore\n</code></pre>\n<p><code>bind</code> is the next thing we will discuss, the point is the this of <code>= { ... }</code>, whatever is type in, there is only <code>{}</code>,\na null object at there! So you will get a null object out of your expected. What does bind do? Let me show it for you.</p>\n<pre><code class=\"language-js\">let printClone = print.bind(obj); // Or obj.print, understanding a truth: function has no relation with any object before we bind(and some other operation) it.\nprintClone(); // `this` at here is `obj`\n// Output: This is obj\n</code></pre>\n<p><code>bind</code> return a new function, combine by a function with a object, use object to be new function's <code>this</code>.</p>\n<p>But we of course want to define function with it's user. How to do that?</p>\n<pre><code class=\"language-js\">function NewCar() {\n  let self = {\n    name: \"Tasla\",\n    price: 100000\n  };\n  return {\n    print() {\n      console.log(self);\n    }\n  };\n}\nlet car = NewCar();\ncar.print(); // Output: { name: \"Tasla\", price: 100000 }\nlet printClone = car.print;\nprintClone(); // Output: { name: \"Tasla\", price: 100000 }\n</code></pre>\n<p>Very interesting, right? Because we use closure at here. We reference the <code>self</code> in <code>NewCar</code>.\nThe most important part came, every time you call <code>NewCar</code> for a new object. The <code>self</code> is different.\nThis is the one of the greatest trick in ES3/5, seems this rule is so complex, why don't use closure to avoid it.\nIn ES3/5, this trick is good enough.</p>\n<p>In ES6, we have <code>class</code>, but what does it real mean?</p>\n<pre><code class=\"language-javascript\">function Car() {\n  this.name = \"Tasla\";\n  this.price = 100000;\n  this.dump = function() {\n    console.log(this);\n  };\n}\nvar car = new Car();\ncar.dump();\nvar clone = car.dump;\nclone(); // Of course, error\n</code></pre>\n<p><code>Car</code> call constructor in ES5, because we can use <code>new</code> ask JS <code>this</code> reference to the object we create.<br>\nBut as you see, the function inside still have dynamic <code>this</code>.<br>\nDon't worry about that, because what I want to say is keyword <code>class</code> work as same as constructor!<br>\nHow we fix it in ES5?</p>\n<pre><code class=\"language-javascript\">function Car() {\n  // ... ignore\n  this.dump = function() {\n    console.log(this);\n  }.bind(this);\n}\n</code></pre>\n<p>Which trick we use at here? First, if we use keyword <code>new</code>, <code>this</code> is the object we created.<br>\nSo we <code>bind</code> target really is that one we expected &#x26; wanted!<br>\nBut this way had some problem, the most important part is hiding ability.<br>\nIn previous solution, we can hide the attributes of <code>object</code> in <code>closure</code>.<br>\nAnd that is the ability we lose at constructor &#x26; <code>class</code>.<br></p>\n<p>How to implement the pattern by <code>class</code>?<br>\nWe have to understand what is <code>class</code> first.<br></p>\n<pre><code class=\"language-javascript\">class Car {\n  constructor() {\n    this.name = \"Tasla\";\n    this.price = 100000;\n    this.dump = this.dump.bind(this);\n  }\n  dump() {\n    console.log(this);\n  }\n}\n</code></pre>\n<p>These code as same as previous solution. So now we know, <code>class</code> is just a syntax sugar.<br>\n<code>class</code> also can not binding correct <code>this</code> for you. You must write done <code>bind</code> at constructor.<br>\nThat is too ridicules, if some one forgive to bind the function(point! I still call it function,\nJS class still not behavior as method as other language), the program will fall into dark.<br>\nSo, how to avoid the problem, the answer is arrow function, arrow function still is a function.<br>\nBut traditional function have a this by execute environment or <code>bind</code> one.<br>\nThen arrow function have a this at it's declared place!<br>\nAnd we go back to <code>class</code>, <code>class</code> provide <code>this</code> at body part!<br></p>\n<pre><code class=\"language-javascript\">class Xxx {\n  // this at here is instance of Xxx!\n}\n</code></pre>\n<p>So we can write these:</p>\n<pre><code class=\"language-javascript\">class Car {\n  constuctor() {\n    this.name = \"Tasla\";\n    this.price = 100000;\n  }\n  dump = () => {\n    console.log(this);\n  };\n}\n</code></pre>\n<p>As your expected, dump always <code>bind</code> with instance of Car.<br>\n!!! <code>dump = ...</code> in a class definition is esNext(stage3) standard, you can always use babel plugin <code>babel-preset-stage-0</code> to follow latest standard.</p>\n<h3>References:</h3>\n<h4><a href=\"https://github.com/getify/You-Dont-Know-JS\">You don't know JS</a></h4>\n<ul>\n<li>Author: Kyle Simpson</li>\n<li>ISBN: 978-986-476-049-7</li>\n</ul>","frontmatter":{"title":"You should know about `this`"}}},"pageContext":{"slug":"/blog/cs/you-should-know-about/"}}}