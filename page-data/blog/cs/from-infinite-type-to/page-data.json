{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/from-infinite-type-to/","result":{"data":{"markdownRemark":{"html":"<p>At <a href=\"https://dannypsnl.github.io/docs/cs/infinite-type/\">infinite type</a> I mention a way(recursive abstract data type) to make we use <code>Option[T]</code> just like <code>T</code>. However, such modeling is not enough. Consider the following example(with the same pseudo syntax takes from <a href=\"https://dannypsnl.github.io/docs/cs/infinite-type/\">infinite type</a>):</p>\n<pre><code>class Foo {\n  bar(): Bar;\n}\n</code></pre>\n<p>Now we want to use <code>Option[Foo]</code> as <code>Foo</code>. In a normal use case, we have:</p>\n<pre><code>foo: Foo = Foo();\nbar: Bar = foo.bar();\n</code></pre>\n<p>Once we put <code>Foo</code> into the box, it became:</p>\n<pre><code>foo: Option[Foo] = Some(Foo());\n// we say use Option[Foo] as Foo, so foo.bar should be supported just like it's existed under Option[Foo]\nbar: Bar = foo.bar();\n</code></pre>\n<p>It seems easy at first look, but consider this case:</p>\n<pre><code>foo: Option[Foo] = None;\nbar: Bar = foo.bar();\n</code></pre>\n<p>What should we do? Terminate program is definitely not what we want, our purpose is reducing the unneeded check(let's say before we surely use the data to show something to UI is not need to check), not create a fragile software. And if we want <code>foo.bar()</code> crash the program at here we even don't have to model <code>Option</code>, just introduce bottom type just like the language that allows null object. So what is our purpose? Is to make <code>foo.bar()</code> automatically returns <code>Option[Bar]</code>.</p>\n<p>Now, let's think about how to make it. Consider this:</p>\n<pre><code>class Foo {\n  bar(): Bar;\n}\nclass Option[Foo] &#x3C;: Foo {\n  bar(): Bar {\n    // implementation\n  }\n}\n</code></pre>\n<p>This model is bad, first, it cannot let <code>Bar</code> became <code>Option[Bar]</code>; second, it causes an interesting problem: <code>Option[Foo]</code> is a subtype of <code>Foo</code> which means the following code is valid:</p>\n<pre><code>foo: Foo = Some(Foo());\n</code></pre>\n<p>However, how do we sure <code>Foo</code> is <code>Option[Foo]</code> or <code>Foo</code> now? In fact, now we make an infinite definition of the type which has a size(such type takes real memory to store), which means we cannot make this kind of type. This is the reason why we have a function called <code>fmap</code> in <strong>Haskell</strong>!</p>\n<p>Take a look at the type of <code>fmap</code>:</p>\n<pre><code class=\"language-hs\">fmap :: (a -> b) -> f a -> fb\n</code></pre>\n<p>For the <code>Maybe</code> type, we create:</p>\n<pre><code class=\"language-hs\">fmap :: (a -> b) -> Maybe a -> Maybe b\nfmap f (Just a) = Just (f a)\n-- We can do nothing with Nothing\nfmap _ Nothing = Nothing\n</code></pre>\n<p>For List: <code>[a]</code> we create:</p>\n<pre><code class=\"language-hs\">fmap :: (a -> b) -> [a] -> [b]\n-- yep, for list, fmap is map\nfmap = map\n</code></pre>\n<p>Ok, so we create such a program for all the box type(such type provide common wrapping for others type)? No!</p>\n<p>In <strong>Haskell</strong>, it actually defines a <code>class</code>(<strong>Haskell</strong> <code>class</code> is very different with <strong>Java</strong> one) for this situation, called <code>Functor</code>:</p>\n<pre><code class=\"language-hs\">class Functor f where\n  fmap :: (a -> b) -> f a -> f b\n\ninstance Functor [] where\n  fmap = map\ninstance Functor Maybe where\n  fmap f (Just a) = Just (f a)\n  fmap _ Nothing = Nothing\n</code></pre>\n<p>We also can create <code>instance Functor (a, b)</code>, like:</p>\n<pre><code class=\"language-hs\">-- `(,) a b` is `(a, b)`, you can find Haskell treats binary operator as a function takes two parameters everywhere(if I'm wrong, tell me)\ninstance Functor ((,) a) where\n  fmap f (x, y) = (x, f y)\n\nfmap (+1) (2, 5)\n-- (2, 6)\nfmap (+1) (3, 5)\n-- (3, 6)\nfmap (+2) (3, 5)\n-- (3, 7)\n</code></pre>\n<p>In this case, <code>f a</code> &#x3C;=> <code>f</code> is <code>(,) a</code>, <code>a</code> is <code>b</code>.</p>\n<p>Now, let's make a mind blow up. I say that binary operator in <strong>Haskell</strong> is all modeling like a function, so <code>a -> b</code> is <code>(->) a b</code>, in fact, I thought people who familiar with <strong>Lisp</strong> would not feel it weird.</p>\n<p>According to <code>(a -> b) -> f a -> f b</code>, first, to make symbol would not conflict, we use: <code>(b -> c) -> f b -> f c</code>. Then use <code>(->) a</code> to replace <code>f</code>: <code>(b -> c) -> ((->) a b) -> ((->) a c)</code>, then normalize it: <code>(b -> c) -> (a -> b) -> (a -> c)</code>. Those knows <strong>Haskell</strong> now should jump and say: Compose! Yes, let's see the definition:</p>\n<pre><code class=\"language-hs\">instance Functor ((->) a) where\n  fmap f fa = f . fa\n</code></pre>\n<p>I hope you have enough fun with <strong>Functor</strong> X).</p>\n<p>Let's back to the problem: How to use <code>Option[Foo]</code> as <code>Foo</code>?</p>\n<pre><code>trait Functor[a] {\n  // let's assuming we have a syntax like this which would require `self` is a type that takes one type parameter and export the type binding to `f` and `a`(and `a` would cause a unification here, since `Functor` have one also, so `a` already bound, `self` has to satisfy it).\n  f[a] = self;\n  fmap[b](self, (a): b): f[b];\n}\n\nclass Option[T] &#x3C;: Functor[T] {\n  fmap[b](self: Option[T], func: (T): b): Option[b] {\n    match self {\n      Some(v) => {\n        return func(v);\n      }\n      None => {\n        return None;\n      }\n    }\n  }\n}\n</code></pre>\n<p>To use it, we cannot keep the totally same code anymore:</p>\n<pre><code>foo: Option[Foo] = Some(Foo());\nbar: Option[Bar] = foo.fmap[Bar](foo.bar);\n</code></pre>\n<p>Now we make an object-syntax-oriented version's <strong>Functor</strong>. You can see the definition is a little bit... ok, very hard to read. But if we really want such extendability(unify box types), then probably is worth it. I haven't mentioned category theory, <strong>Applicative</strong>(finally!) and other things in <strong>Haskell</strong> or other languages. Hopefully, I can complete them in the future, and in the end thanks for your read.</p>","frontmatter":{"title":"From Infinite Type to Functor"}}},"pageContext":{"slug":"/blog/cs/from-infinite-type-to/"}}}