{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/note-bound/","result":{"data":{"markdownRemark":{"html":"<p>Bounded polymorphism refers to existential quantifiers(<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi></mrow><annotation encoding=\"application/x-tex\">\\exists</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">∃</span></span></span></span>), restricted to range over types of bound type. To understand it only needs a few examples. Let's start! Take a look at the following program:</p>\n<pre><code class=\"language-hs\">numSort :: Num a => [a] -> [a]\n</code></pre>\n<p><code>Num a</code> is how we represent the bounded polymorphism in <strong>Haskell</strong>, the definition of <code>Num</code> was <code>class Num b where</code>(Hoogle shows <code>a</code>, just prevent to confuse reader don't familiar with <strong>Haskell</strong>) could read as <strong>a type <code>b</code> is an instance of class <code>Num</code></strong>.</p>\n<p>So <code>numSort</code> takes <code>[a]</code> only if <code>a</code> is an instance of <code>Num</code>. Now we could run down:</p>\n<pre><code class=\"language-hs\">numSort [1, 2, 3] :: [Int]\nnumSort [1.1, 2, 3] :: [Double]\n</code></pre>\n<p>This is really a powerful feature(and you don't need to use <strong>Haskell</strong> for this, <strong>Java</strong> also has this feature), consider the old way to do <code>List&#x3C;A></code> to <code>List&#x3C;B></code>, and unfortunately solution was to copy each element in the list.</p>","frontmatter":{"title":"NOTE: bounded polymorphism"}}},"pageContext":{"slug":"/blog/cs/note-bound/"}}}