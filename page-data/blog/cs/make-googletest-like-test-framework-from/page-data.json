{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/make-googletest-like-test-framework-from/","result":{"data":{"markdownRemark":{"html":"<p>Back to 2016, I learned <a href=\"https://github.com/google/googletest\">googletest</a> how improving my C++ project. From that, I always want to know how it.</p>\n<p>Let's take a look at some basic example of it.</p>\n<pre><code class=\"language-cpp\">TEST(Arithmetic, Integer) {\n  ASSERT_EQ(1 + 2, 3);\n}\n</code></pre>\n<p>I think that's pretty easy to understanding for anyone ever wrote a unit test.</p>\n<p>In the googletest context, you would get a lot of <code>TEST</code> there like:</p>\n<pre><code class=\"language-cpp\">TEST(Suit1, test1) {\n  // ...\n}\nTEST(Suit1, test2) {\n  // ...\n}\n\nTEST(Suit2, test1) {\n  // ...\n}\nTEST(Suit2, test2) {\n  // ...\n}\n</code></pre>\n<p>Back to our article, think about it, why the compiler does not complain <code>TEST</code> be redefined so many times, and never specify the type of parameters(and the return type)?</p>\n<p>Answer: Because that is not a function.</p>\n<p>Then the question became: what it that?</p>\n<p>The answer is clear, it's a C macro! Only the macro can behave like a function call format <code>TEST(Suit, Test)</code>.</p>\n<p>As everyone knows, C macro just expands codes inside of it. So the question changed again and now it's: What kind of codes can be valid after expanded with a code block at the global level?</p>\n<p>The answer to this also it easy: a function(or a method implementation because we're using C++).</p>\n<p>After so many words, let's start coding! Create a file <code>unittest.hpp</code>, code:</p>\n<pre><code class=\"language-cpp\">#ifndef UNITTEST\n#define UNITTEST\n\n#define TEST(suit, test)\n\n#endif\n</code></pre>\n<p>So we can have a <code>main.cpp</code> with code:</p>\n<pre><code>#include \"./unittest.hpp\"\n\nTEST(Arithmetic, Integer)\n</code></pre>\n<p>Then compile: <code>g++ main.cpp</code>, this should fine now.</p>\n<p>Then we add a code block:</p>\n<pre><code>TEST(Arithmetic, Integer) {}\n</code></pre>\n<p>Oops!</p>\n<pre><code>$ g++ main.cpp\nmain.cpp:3:27: error: expected unqualified-id\nTEST(Arithmetic, Integer) {}\n                          ^\n1 error generated.\n</code></pre>\n<p>Let's fix it. In your <code>unittest.hpp</code>, typed:</p>\n<pre><code>#define TEST(suit, test) void foo()\n</code></pre>\n<p>This time, compiler very happy without any complains. So we have to go to the next step: How to executing these tests automatically?</p>\n<p>To do that, we must have a place that stores(or reference to) our tests. So we create a global variable.</p>\n<pre><code class=\"language-cpp\">#include &#x3C;functional> // for std::function\n#include &#x3C;vector> // for std::vector\n\nstd::vector&#x3C;std::function&#x3C;void()>> all_test;\n</code></pre>\n<p>And add an insertion call in macro <code>TEST</code>:</p>\n<pre><code class=\"language-cpp\">#define TEST(suit, test)                                                       \\\n  void foo();                                                                  \\\n  all_test.push_back(foo);                                                     \\\n  void foo()\n</code></pre>\n<pre><code>$ g++ -std=c++11 main.cpp\nmain.cpp:3:1: error: unknown type name 'all_test'\nTEST(Arithmetic, Integer) {}\n^\n././unittest.hpp:11:3: note: expanded from macro 'TEST'\n  all_test.push_back(foo);                                                     \\\n  ^\nmain.cpp:3:1: error: cannot use dot operator on a type\n././unittest.hpp:11:11: note: expanded from macro 'TEST'\n  all_test.push_back(foo);                                                     \\\n          ^\n2 errors generated.\n</code></pre>\n<p>But it won't work, let's see what happened here. The error message is about compiler expects there is a type <code>all_test</code> but didn't, then it complains a type name can't contain <code>.</code>.</p>\n<p>To bypass the error and get expected insertion call we need some interesting trick. It's all about C++ constructor promised to be called while the structure is created.</p>\n<pre><code class=\"language-cpp\">struct unittest_insert {\n  unittest_insert(std::function&#x3C;void()> &#x26;&#x26;f);\n};\n\nunittest_insert::unittest_insert(std::function&#x3C;void()> &#x26;&#x26;f) {\n  all_test.push_back(f);\n}\n\n#define TEST(suit, test)                                                       \\\n  void foo();                                                                  \\\n  unittest_insert ut{foo};                                                     \\\n  void foo()\n</code></pre>\n<p>Now, let's add some print statement into our test and implements run all tests to prove what have we done is workable. The content of <code>main.cpp</code>:</p>\n<pre><code class=\"language-cpp\">#include &#x3C;iostream>\n\n#include \"./unittest.hpp\"\n\nTEST(Arithmetic, Integer) {\n  std::cout &#x3C;&#x3C; \"test \"\n            &#x3C;&#x3C; \"test\" &#x3C;&#x3C; std::endl;\n}\n\nint main() {\n  run_all_tests();\n  return 0;\n}\n</code></pre>\n<p>Implementation of <code>run_all_tests</code>:</p>\n<pre><code class=\"language-cpp\">void run_all_tests() {\n  for (auto test : all_test) {\n    test();\n  }\n}\n</code></pre>\n<p>Now we knew how to run tests. We need to know how to determine a fail.\nThat's why we need assertion macros. Here is an example of testing:</p>\n<pre><code class=\"language-cpp\">TEST(Arithmetic, Integer) { ASSERT_EQ(1, 1); }\n</code></pre>\n<p>Then see how <code>ASSERT_EQ</code> be made.</p>\n<pre><code class=\"language-cpp\">#define ASSERT_EQ(le, re)                                                      \\\n  if (le != re) {                                                              \\\n    throw \"assert equal failed\";                                               \\\n  }\n</code></pre>\n<p><code>g++ -std=c++11 main.cpp</code> and run, where interesting thing is what if you write <code>ASSERT_EQ(1, 2)</code> that you would get a runtime error says:</p>\n<pre><code>libc++abi.dylib: terminating with uncaught exception of type char const*\n[1]    35777 abort      ./a.out\n</code></pre>\n<p>But before going to improving our error reporting, we should think about a problem: Can we create the second one test? The answer is <strong>NO</strong>.</p>\n<p>You can have a try then get a list of redefinition errors from the compiler. To solve the problem we need to get some help from the macro.</p>\n<pre><code class=\"language-cpp\">#define TEST(suit, test)                                                       \\\n  void utf_suit##test();                                                       \\\n  unittest_insert ut_suit##test{utf_suit##test};                               \\\n  void utf_suit##test()\n</code></pre>\n<p><code>##</code>, the magic from the macro, you can get more helps from <a href=\"https://stackoverflow.com/questions/4364971/and-in-macros\">https://stackoverflow.com/questions/4364971/and-in-macros</a></p>\n<p>Now, we won't get the error from expanding the macro twice. And could get a chance to stop and think about the error reporting design.</p>\n<p>At now, we just <code>throw</code> a <code>char const *</code>, and we didn't catch the exception, so we would receive a <code>terminating with uncaught exception</code> error. That caused two problems:</p>\n<ul>\n<li>The test won't keep going caused users won't know how many tests failed actually.</li>\n<li>And users don't know what exception been throw actually.</li>\n</ul>\n<p>To solve the problem, what the thing we should do is catch the exception, report and keep going on. Here is the code:</p>\n<pre><code class=\"language-cpp\">#include &#x3C;exception>\n\nvoid run_all_tests() {\n  for (auto test : all_test) {\n    try {\n      test();\n      std::cout &#x3C;&#x3C; \"test pass\" &#x3C;&#x3C; std::endl;\n    } catch (char const *e) {\n      std::cerr &#x3C;&#x3C; e &#x3C;&#x3C; std::endl;\n    } catch (std::exception &#x26;e) {\n      std::cerr &#x3C;&#x3C; e.what() &#x3C;&#x3C; std::endl;\n    } catch (...) {\n      std::cerr &#x3C;&#x3C; \"test failed: unknown exception\" &#x3C;&#x3C; std::endl;\n    }\n  }\n}\n</code></pre>\n<p>Now it would report test passed or not, it looks nice as a proof of concept.</p>\n<p>Now counting what do we learn from these?</p>\n<ul>\n<li>How to generate a function from the macro</li>\n<li>How to handle the exception</li>\n</ul>\n<p>And here have some exercises you can do.</p>\n<ul>\n<li>improve the error reporting, not just say assertion failed, also show the expression why isn't equal(hint: custom exception)</li>\n<li>how to avoid user access the generated function?(hint: try generating class)</li>\n<li>can we report the coverage? (hint: <code>llvm-cov</code> or similar things)</li>\n<li>what if the input expression is not comparable?</li>\n</ul>","frontmatter":{"title":"Make googletest-like test framework from scratch"}}},"pageContext":{"slug":"/blog/cs/make-googletest-like-test-framework-from/"}}}