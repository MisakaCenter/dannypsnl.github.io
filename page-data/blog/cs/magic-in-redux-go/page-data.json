{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/magic-in-redux-go/","result":{"data":{"markdownRemark":{"html":"<p>A few days ago, I release the redux-go v2.1</p>\n<p>The purpose is: create reducer &#x26; action then manage relationships between them is pretty hard!</p>\n<p>Let's getting start from basic v2 store</p>\n<pre><code class=\"language-go\">// package reducer\nfunc Counter(state int, action string) int {\n    switch action {\n    case \"INCREASE\":\n        return state + 1\n    case \"DECREASE\":\n        return state + 1\n    default:\n        return state\n    }\n}\n\n// func main\nstore := store.New(reducer.Counter)\nstore.Dispatch(\"INCREASE\")\nstore.StateOf(reducer.Counter)\n</code></pre>\n<p>When you got 30 reducers, each contains 3 actions, how to manage this complex?</p>\n<p>In the traditional way, we follow a restrict naming rule.</p>\n<p>For example:</p>\n<pre><code class=\"language-go\">// package reducer/counter\nconst (\n    Increase = \"REDUCER_COUNTER_INCREASE\"\n    Decrease = \"REDUCER_COUNTER_DECREASE\"\n)\n\n// package reducer\nfunc Counter(state int, action string) int\n\n// func main\nstore := store.New(reducer.Counter)\nstore.Dispatch(counter.Increase)\nstore.StateOf(reducer.Counter)\n</code></pre>\n<p>How to spread these actions is not important, the point is we manage them by handcraft! And handcraft cause unstable!</p>\n<p>That's why we need package Rematch.</p>\n<p>It creates a more native way to manage your reducer-action relationship.</p>\n<pre><code class=\"language-go\">// package reducer/todo\nvar Reducer *todoModel\n\nfunc init() {\n    Reducer = &#x26;todoModel{\n        State: make([]Todo, 0),\n    }\n}\n\ntype Todo struct {\n    Title string\n    Done bool\n}\n\ntype Model []Todo\n\ntype todoModel struct {\n    rematch.Reducer\n    State Model\n}\n\nfunc (todo *todoModel) AddTodo(state Model, title string) Model {\n    return append(state, Todo{Title: title})\n}\n</code></pre>\n<p>Now when we using it, the relationship became pretty obviously</p>\n<pre><code class=\"language-go\">// func main\nstore := store.New(todo.Reducer)\naddTodo := todo.Reducer.Action(todo.Reducer.AddTodo)\n\nstore.Dispatch(addTodo.With(\"first todo\"))\nstore.Dispatch(addTodo.With(\"second todo\"))\n\nstore.StateOf(todo.Reducer)\n</code></pre>\n<p>It takes more code but also more restrictive than the manual way to create it.</p>\n<p>Now, let's take a look at what made these happened.</p>\n<p>First, we start from <code>store.New</code>(base on v2.1.1)</p>\n<pre><code class=\"language-go\">// package store\nfunc New(reducers ...interface{}) *Store {\n    newStore := &#x26;Store{\n        reducers: make(map[uintptr]reflect.Value),\n        state:    make(map[uintptr]reflect.Value),\n    }\n    // later\n}\n</code></pre>\n<p>The first difference is <code>Store.reducers</code> because, with <code>rematch</code>, reducer's address can't mapping to state, I will explain it later.</p>\n<pre><code class=\"language-go\">// func store.New\nfor _, reducer := range reducers {\n    r := reflect.ValueOf(reducer)\n    checkReducer(r)\n\n    if _, ok := newStore.state[r.Pointer()]; ok {\n        panic(\"You can't put duplicated reducer into the same store!\")\n    }\n\n    actualReducer, initState := getReducerAndInitState(r)\n\n    newStore.reducers[r.Pointer()] = actualReducer\n    newStore.state[r.Pointer()] = initState\n}\nreturn newStore\n</code></pre>\n<p>We still checking reducer, let's view it</p>\n<pre><code class=\"language-go\">// func checkReducer, adding part\nif r.Kind() == reflect.Ptr {\n    v := reflect.Indirect(r) // dereference from ptr\n    if v.FieldByName(\"State\").Kind() == reflect.Invalid {\n        panic(\"Reducer structure must contains field[State]\")\n    }\n}\n</code></pre>\n<p>We add checking <code>Kind</code> is <code>Ptr</code>, because of <code>rematch.Reducer</code> sends a pointer of it into the store!</p>\n<p>If we can't find field <code>State</code>, we say the reducer is invalid and panic(this is a protocol really missing, but only the writer has to worry about, the user only need to know they have to create this field). So we can promise we don't have to check these at the following flow.</p>\n<p>Then we check the state already exist or not in the store. If the answer is yes, we panic it.</p>\n<p>Final, we have to get initial state and actual reducer, why it called <code>actual reducer</code>? Because we can't really execute a structure! The reducer will execute in progress is another thing. It created by package rematch. So let's dig into <code>getReducerAndInitState</code> this function to understanding how it works and why we have to change the type of <code>Store.reducers</code>.</p>\n<pre><code class=\"language-go\">// func getReducerAndInitState\nif r.Kind() == reflect.Ptr {\n    v := reflect.Indirect(r) // dereference from ptr\n    return r.MethodByName(\"InsideReducer\").\n        Call([]reflect.Value{r})[0],\n        v.FieldByName(\"State\")\n}\nreturn r, r.Call(\n    []reflect.Value{\n    // We just use their zero value for initialize\n        reflect.Zero(r.Type().In(0)), // In index 0 is state\n        reflect.Zero(r.Type().In(1)), // In index 1 is action\n    },\n    )[0] // 0 at here is because checkReducer promise that we will only receive one return\n</code></pre>\n<p>The same, Kind is Ptr means it's <code>rematch.Reducer</code>.</p>\n<p>Remember <code>actualReducer, initState := getReducerAndInitState(r)</code> this line, we got <code>(reducer, state)</code> pair.</p>\n<p>Now, when we receive a <code>rematch.Reducer</code>, <code>reducer</code> produce by <code>InsideReducer</code>, where is it? We do not see it at any user's code, right? Because it's defined at package <code>rematch</code>, export it is because reflection can only take exported member!</p>\n<p>Else it's original reducer(a normal function apply reducer required), we won't talk about it again, you can refer to <a href=\"https://dannypsnl.github.io/golang/redux/2018/05/17/design-of-redux-go-v2.html\">design-of-redux-go-v2</a> to getting more information.</p>\n<p>Back to InsideReducer</p>\n<pre><code class=\"language-go\">// package rematch\nfunc (r Reducer) InsideReducer(v interface{}) func(interface{}, *action) interface{} {\n    r.ms = r.methods(v)\n    return func(state interface{}, action *action) interface{} {\n        return r.ms[action.reducerName()].Call(\n            []reflect.Value{\n                reflect.ValueOf(state),\n                reflect.ValueOf(action.payload()),\n            },\n        )[0].Interface()\n    }\n}\n</code></pre>\n<p>As you can see, it returns a normal reducer finally, then you can find it very depends on <code>r.methods</code>. What is that? Let's view its definition.</p>\n<pre><code class=\"language-go\">// package rematch\nfunc (r Reducer) methods(v interface{}) map[string]reflect.Value {\n    rv := reflect.ValueOf(v)\n    rt := reflect.TypeOf(v)\n    methods := make(map[string]reflect.Value)\n    for i := 1; i &#x3C; rt.NumMethod(); i++ {\n        m := rt.Method(i) // rt.Method.Func return func with first argument as receiver\n        mt := m.Type\n        if mt.NumIn() == 3 &#x26;&#x26;\n            mt.NumOut() == 1 &#x26;&#x26;\n            mt.In(1) == mt.Out(0) {\n            // rv.Method return func with now receiver\n            methods[m.Name] = rv.Method(i)\n        }\n    }\n    return methods\n}\n</code></pre>\n<p><code>methods</code> get user-defined rematcher(back to <code>InsideReducer</code> &#x26; <code>getReducerAndInitState</code>, you will find this passing flow), overviewing every method, if anything looks like an inside reducer, put it into method map.</p>\n<p>Now you could have several confused points.</p>\n<ol>\n<li>why using <code>m.Name</code>, not address</li>\n<li>why using <code>mt.In(1)</code>, not <code>mt.In(0)</code></li>\n<li>why <code>NumIn()</code> should be 3</li>\n</ol>\n<p>First question's answer is, instance to method &#x26; type to method has the different address! It's not hard to understand when you know that there has no <code>user-type</code> in final machine code. We will create a table(or other things, not important) to represent <code>user-type</code>. But we can get the same name(type info will store it).</p>\n<p>Second's answer and third's are same, reflection type of structure's method <code>Method</code> return an underlying function of method.</p>\n<p>For example, we have a type <code>K</code>, <code>K</code> has a method <code>foo()</code>, there has no <code>K.foo()</code> in this world, we have <code>foo(*K)</code> actually, and that's what <code>rt.Method(i)</code> gave you!</p>\n<p>Finally, let's take a look at <code>action</code>. The last puzzle of this crazy tutorial.</p>\n<pre><code class=\"language-go\">// package rematch\ntype action struct {\n    funcName string\n    with     interface{}\n}\n</code></pre>\n<p>This is how it looks like. We store method's name &#x26; payload named as <code>with</code>.</p>\n<p>We used <code>Action</code> to create our action</p>\n<pre><code class=\"language-go\">// package rematch\nfunc (r Reducer) Action(method interface{}) *action {\n    return &#x26;action{\n        funcName: getReducerName(method),\n    }\n}\n</code></pre>\n<p>Now, we believing <code>getReducerName</code> work correctly first, and mention it later.</p>\n<p>As your expected, <code>With</code> just set up the payload.</p>\n<pre><code class=\"language-go\">// package rematch\nfunc (a *action) With(payload interface{}) *action {\n    a.with = payload\n    return a\n}\n</code></pre>\n<p><code>reducerName</code> &#x26; <code>payload</code> used in <code>InsideReducer</code>, them don't need to explain, just return the thing that action kept.</p>\n<pre><code class=\"language-go\">// package rematch\nfunc (a action) reducerName() string {\n    return a.funcName\n}\n\nfunc (a action) payload() interface{} {\n    return a.with\n}\n</code></pre>\n<p><code>getReducerName</code> is the fuzziest thing, but just like we had mentioned, a method is a function that first parameter is its receiver!</p>\n<pre><code class=\"language-go\">// package rematch\nfunc getReducerName(r interface{}) string {\n    fullName := runtime.FuncForPC(reflect.ValueOf(r).Pointer()).Name()\n    // fullName's format is `package.function_name`\n    // we don't want package part.\n    // package is full path(GOPATH/src/package_part) to it\n    // len-3 is because a method contains suffix `-fm`\n    return fullName[strings.LastIndexByte(fullName, '.')+1 : len(fullName)-3]\n}\n</code></pre>\n<p>But why is <code>len(fullName)-3</code>? The reason is that you can have <code>Foo</code> &#x26; <code>Foo(*K)</code> at the same time! The solution Go pick is suffixed all method by <code>-fm</code>!</p>\n<p>Now you know why we cut it. Because of the type of method.Name does not have this suffix, we want to map them, so we have to follow their rules.</p>\n<p>With these change, now we can work with a native relationship between reducer &#x26; action! And a nice sleep I guess?</p>","frontmatter":{"title":"Magic in redux-go v2.1: package rematch"}}},"pageContext":{"slug":"/blog/cs/magic-in-redux-go/"}}}