{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/a-racket-macro-tutorial-get-http-parameters/","result":{"data":{"markdownRemark":{"html":"<p>A few days ago, I post this <a href=\"https://dev.to/dannypsnl/comment/ldl8\">answer</a> to respond to a question about Racket's web framework. When researching on which frameworks could be used. I found no frameworks make get values from HTTP request easier. So I start to design a macro, which based on <a href=\"github.com/Junker/routy\">routy</a> and an assuming function <code>http-form/get</code>, as following shows:</p>\n<pre><code class=\"language-racket\">(get \"/user/:name\"\n  (lambda ((name route) (age form))\n    (format \"Hello, ~a. Your age is ~a.\" name age)))\n</code></pre>\n<p>Let me explain this stuff. <code>get</code> is a macro name, it's going to take a string as route and a \"lambda\" as a request handler. <code>((name route) (age form))</code> means there has a parameter <code>name</code> is taken from <code>route</code> and a parameter <code>age</code> is taken from <code>form</code>. And <code>(format \"Hello, ~a. Your age is ~a.\" name age)</code> is the body of the handler function.</p>\n<p>Everything looks good! But we have no idea how to make it, not yet ;). So I'm going to show you how to build up this macro step by step, as a tutorial.</p>\n<p>First, we have to ensure the target. I don't want to work with original Racket HTTP lib because I never try it, so I pick <a href=\"github.com/Junker/routy\">routy</a> as a routing solution. A <a href=\"github.com/Junker/routy\">routy</a> equivalent solution would look like:</p>\n<pre><code class=\"language-racket\">(routy/get \"/user/:name\"\n  (lambda (req params)\n    (format \"Hello, ~a. Your age is ~a.\" (request/param params 'name) (http-form/get req \"age\"))))\n</code></pre>\n<blockquote>\n<p>WARNING: There has no function named <code>http-form/get</code>, but let's assume we have such program to focus on the topic of the article: <strong>macro</strong></p>\n</blockquote>\n<p>Now we can notice that there was no <code>name</code>, <code>age</code> in <code>lambda</code> now. But have to get it by using <code>request/param</code> and <code>http-form/get</code>. But there also has the same pattern, the route! To build up macro, we need the following code at the top of the file <code>macro.rkt</code> first:</p>\n<pre><code class=\"language-racket\">#lang racket\n\n(require (for-syntax racket/base racket/syntax syntax/parse))\n</code></pre>\n<p>Then we get our first macro definition:</p>\n<pre><code class=\"language-racket\">(define-syntax (get stx)\n  (syntax-parse stx\n    [(get route:str)\n      #'(quote\n        (routy/get route\n          (lambda (req params)\n            'body)))]))\n\n(get \"/user/:name\")\n; output: '(routy/get \"/user/:name\" (lambda (req params) 'body))\n</code></pre>\n<p>Let's take a look at each line, first, we have <code>define-syntax</code>, which is like <code>define</code> but define a macro. It contains two parts, <strong>name</strong> and <code>syntax-parse</code>. The name part was <code>(get stx)</code>, so the macro called <code>get</code>, with a syntax object <code>stx</code>. The <code>syntax-parse</code> part was:</p>\n<pre><code class=\"language-racket\">(syntax-parse stx\n  [(get route:str)\n    #'(quote\n      (routy/get route\n        (lambda (req params)\n          'body)))])\n</code></pre>\n<p>The <code>syntax-parse</code> part works on the syntax object, so it's arguments are a syntax object and patterns! Yes, patterns! It's ok to have multiple patterns like this:</p>\n<pre><code class=\"language-racket\">(define-syntax (multiple-patterns? stx)\n  (syntax-parse stx\n    [(multiple-patterns? s:str) #'(quote ok-str)]\n    [(multiple-patterns? s:id) #'(quote ok-id)]))\n\n(multiple-patterns? \"\")\n; output: 'ok-str\n(multiple-patterns? a)\n; output: 'ok-id\n</code></pre>\n<p>Now we want to add handler into <code>get</code>, to reduce the complexity, we introduce another feature: <code>define-syntax-class</code>. The code would become:</p>\n<pre><code class=\"language-racket\">(define-syntax (get stx)\n  (define-syntax-class handler-lambda\n    #:literals (lambda)\n    (pattern (lambda (arg*:id ...) clause ...)\n      #:with\n      application\n      #'((lambda (arg* ...)\n           clause ...)\n         arg* ...)))\n\n  (syntax-parse stx\n    [(get route:str handler:handler-lambda)\n      #'(quote\n        (routy/get route\n          (lambda (req params)\n            handler.application)))]))\n</code></pre>\n<p>First we compare <code>syntax-parse</code> block, we add <code>handler:handler-lambda</code> and <code>handler.application</code> here:</p>\n<pre><code class=\"language-racket\">(syntax-parse stx\n  [(get route:str handler:handler-lambda)\n    #'(quote\n      (routy/get route\n        (lambda (req params)\n          handler.application)))]))\n</code></pre>\n<p>This is how we use a <code>define-syntax-class</code> in a higher-level syntax. <code>handler:handler-lambda</code> just like <code>route:str</code>, the only differences are their pattern. <code>route:str</code> always expected a string, <code>handler:handler-lambda</code> always expected a <code>handler-lambda</code>. And notice that <code>handler:handler-lambda</code> would be the same as <code>a:handler-lambda</code>, just have to use <code>a</code> to refer to that object. But better give it a related name.</p>\n<p>Then dig into <code>define-syntax-class</code>:</p>\n<pre><code class=\"language-racket\">(define-syntax-class handler-lambda\n  #:literals (lambda)\n  (pattern (lambda (arg*:id ...) clause* ...)\n    #:with\n    application\n    #'((lambda (arg* ...)\n        clause* ...)\n        arg* ...)))\n</code></pre>\n<p><code>define-syntax-class</code> allows us add some <code>stxclass-option</code>, for example: <code>#:literals (lambda)</code> marked <code>lambda</code> is not a pattern variable, but a literal pattern. The body of <code>define-syntax-class</code> is a pattern, which takes a pattern and some <code>pattern-directive</code>. The most important <code>pattern-directive</code> was <code>#:with</code>, which stores how to transform this pattern, it takes a <code>syntax-pattern</code> and an <code>expr</code>, as you already saw, this is usage: <code>handler.application</code>.</p>\n<p>The interesting part was <code>...</code> in the pattern, it means zero to many patterns. A little tip makes such variables with a suffix <code>*</code> like <code>arg*</code> and <code>clause*</code> at here.</p>\n<p>Now take a look at usage:</p>\n<pre><code class=\"language-racket\">(get \"/user/:name\"\n  (lambda (name age)\n    (format \"Hello, ~a. Your age is ~a.\" name age)))\n; output: '(routy/get \"/user/:name\" (lambda (req params) ((lambda (name age) (format \"Hello, ~a. Your age is ~a.\" name age)) name age)))\n</code></pre>\n<p>There are some issues leave now, since we have to distinguish <code>route</code> and <code>form</code>, current pattern of <code>handler-lambda</code> is not enough. The <code>handler-lambda.application</code> also incomplete, we need</p>\n<pre><code class=\"language-racket\">(lambda (req params)\n  (format \"Hello, ~a. Your age is ~a.\"\n          (request/param params 'name)\n          (http-form/get req \"age\")))\n</code></pre>\n<p>but get</p>\n<pre><code class=\"language-racket\">(lambda (req params)\n  ((lambda (name age)\n    (format \"Hello, ~a. Your age is ~a.\"\n            name\n            age)) name age))\n</code></pre>\n<p>right now.</p>\n<p>To decompose the abstraction, we need another <code>define-syntax-class</code>.</p>\n<pre><code class=\"language-racket\">(define-syntax-class argument\n    (pattern (arg:id (~literal route))\n      #:with get-it #'[arg (request/param params 'arg)])\n    (pattern (arg:id (~literal form))\n      #:with get-it #'[arg (http-form/get req (symbol->string 'arg))]))\n\n(define-syntax-class handler-lambda\n  #:literals (lambda)\n  (pattern (lambda (arg*:argument ...) clause* ...)\n    #:with\n    application\n    #'(let (arg*.get-it ...)\n         clause* ...)))\n</code></pre>\n<p>There are two changes, replace <code>lambda</code> with <code>let</code> in <code>handler-lambda.application</code>(it's more readable), and use <code>argument</code> syntax type instead of <code>id</code>.</p>\n<p><code>argument</code> has two patterns, <code>arg:id (~literal route)</code> and <code>arg:id (~literal form)</code> to match <code>(x route)</code> and <code>(x form)</code>. Notice that <code>#:literals (x)</code> and <code>(~literal x)</code> has the same ability, just pick a fit one. <code>symbol->string</code> converts an atom to a string, here is an example:</p>\n<pre><code class=\"language-racket\">(symbol->string 'x)\n; output: \"x\"\n</code></pre>\n<p>Let's take a look at usage:</p>\n<pre><code class=\"language-racket\">(get \"/user/:name\"\n  (lambda ((name route) (age form))\n    (format \"Hello, ~a. Your age is ~a.\" name age)))\n; output: '(routy/get \"/user/:name\" (lambda (req params) (let ((name (request/param params 'name)) (age (http-form/get req (symbol->string 'age)))) (format \"Hello, ~a. Your age is ~a.\" name age))))\n</code></pre>\n<p>Manually pretty output:</p>\n<pre><code class=\"language-racket\">'(routy/get \"/user/:name\"\n  (lambda (req params)\n    (let ((name (request/param params 'name))\n          (age (http-form/get req (symbol->string 'age))))\n      (format \"Hello, ~a. Your age is ~a.\" name age))))\n</code></pre>\n<h3>Summary</h3>\n<p>With make up this tutorial, I learn a lot of macro tips in Racket that I don't know before. I hope you also enjoy this, also hope you can use everything you learn from here to create your helpful macro. Have a nice day.</p>\n<h3>End up, all code</h3>\n<pre><code class=\"language-racket\">#lang racket\n\n(require (for-syntax racket/base racket/syntax syntax/parse))\n\n(define-syntax (get stx)\n  (define-syntax-class argument\n    (pattern (arg:id (~literal route))\n      #:with get-it #'[arg (request/param params 'arg)])\n    (pattern (arg:id (~literal form))\n      #:with get-it #'[arg (http-form/get req (symbol->string 'arg))]))\n\n  (define-syntax-class handler-lambda\n    #:literals (lambda)\n    (pattern (lambda (arg*:argument ...) clause* ...)\n      #:with\n      application\n      #'(let (arg*.get-it ...)\n           clause* ...)))\n\n  (syntax-parse stx\n    [(get route:str handler:handler-lambda)\n      #'(quote\n        (routy/get route\n          (lambda (req params)\n            handler.application)))]))\n\n(get \"/user/:name\"\n  (lambda ((name route) (age form))\n    (format \"Hello, ~a. Your age is ~a.\" name age)))\n</code></pre>","frontmatter":{"title":"A Racket macro tutorial -- get HTTP parameters easier"}}},"pageContext":{"slug":"/blog/cs/a-racket-macro-tutorial-get-http-parameters/"}}}