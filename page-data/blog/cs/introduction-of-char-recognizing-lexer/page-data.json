{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/introduction-of-char-recognizing-lexer/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>此篇使用 Rust 作為演示實際程式碼的語言</p>\n</blockquote>\n<p>說到 Lexer 技術，大家應該都會想到正規表達式，但是為什麼是正規表達式呢？\n所以我們要介紹整個掃描並辨識字詞的技術與原理</p>\n<p>最簡單的辨識單字技術是大家都能直接想出來的方法，就是 character-by-character 演算法</p>\n<p>其技術原理非常簡潔，如果要辨識<code>new</code>，我們會怎麼做呢？</p>\n<script src=\"https://gist.github.com/dannypsnl/53e8b814c7407e8621fbe05d45e7cb67.js\"></script>\n<p>可以看出為什麼每個人都想得出來吧！因為整個 CBC 的邏輯就是完全符合的字串就是我們要的字串</p>\n<p>但是問題來了，如果我們想要辨識<code>night</code>怎麼辦呢？每個我們想要的字串都寫一個辨識程式的話，那不是很浪費空間跟時間嗎？\n所以我們需要縮減程式，如何縮減？</p>\n<p>我們可以很輕鬆的發現其實<code>new</code>與<code>night</code>的第一個字元都是<code>n</code>，所以我們可以把程式變成：</p>\n<script src=\"https://gist.github.com/dannypsnl/097fe61c1bbbf7835cbd14336fc66cda.js\"></script>\n<p>這樣的簡化對問題的根源沒有幫助，但是引出了重點，我們可以有多種線路的選擇，那麼能不能讓多種線路移至同樣地狀態呢？\n答案當然是可以的。為了說明清楚我在說什麼，讓我們用圖來描述<code>is_new</code>做了什麼：</p>\n<div id=\"state_machine_graphic_of_new\"></div>\n<p><code>s0</code>是我們的初始狀態，紅色代表接受狀態，所謂接受狀態你也可以說是辨識成功，一般來說我們會省略錯誤狀態，你只要找不到對應的<code>edge</code>我們就會移至錯誤狀態</p>\n<p>那麼我們再看與規則<code>night</code>結合後的圖</p>\n<pre><code>   n     e     w\ns0 -> s1 -> s2 -> s3(sª)\n         i     g     h     t\n         -> s4 -> s5 -> s6 -> s7(sª)\n</code></pre>\n<p>所以所謂的多種線路移至同一狀態是什麼意思呢？假設我們要辨識一個英文單字，我們只需要是<code>a..z</code>(不管大小寫)都接受，所以圖就是：</p>\n<pre><code>   a     a\ns0 -> s1 -> s1 -> ... -> s1\n   b\n   -> s1\n   c\n   -> s1\n   ...\n   ...\n   ...\n   z\n   -> s1\n</code></pre>\n<p>可以發現模式是重複而無限的，所以我們可以簡化成：</p>\n<pre><code>  a..z\ns0 -> s1 &#x3C;--\n      |    | a..z\n       \\__/\n</code></pre>\n<p>ps. 這裡的<code>s1</code>是<code>sª</code></p>\n<p>那麼這樣的狀態圖要如何實作呢？</p>\n<script src=\"https://gist.github.com/dannypsnl/301605038c23d828acc1447ced5f9cf4.js\"></script>\n<p>就跟圖一樣需要用個迴圈處理重複的工作，當然你也可以用遞迴的方式實作：</p>\n<script src=\"https://gist.github.com/dannypsnl/12fe67d584857d1810f5d460f77d12af.js\"></script>\n<p>看完思想跟實作之後，讓我們深入了解數學定義吧！\n我們稱這種辨識技術為<code>有限狀態自動機</code>(<code>Finite Automata</code>)，其數學式由五個元組組成。\n分別是：<code>S</code>, <code>∑</code>, <code>∂</code>, <code>s0</code>, <code>sª</code></p>\n<p><code>S</code>代表所有狀態的集合(包含錯誤狀態)，<code>∑</code>代表所有邊界標籤的聯集，<code>∂</code>代表所有轉換函數的集合，<code>s0</code>是初始狀態，<code>sª</code>是接受狀態</p>\n<p>以一開始的<code>new</code>為例：</p>\n<pre><code>S = {s0, s1, s2, s3, se}\n∑ = {n, e, w}\n∂ = {\n     n\n  s0 -> s1,\n     e\n  s1 -> s2,\n     w\n  s2 -> s3,\n}\ns0 = s0\nSª = {s3}\n</code></pre>\n<p>很明顯的，FA 的表示法非常麻煩，那麼就回到大家熟悉的正規表達式了。\n我不贅述怎麼寫正規表達式，有很多專門介紹正規表達式的文章了</p>\n<p>以<code>Antlr</code>的<code>new</code>為例：</p>\n<pre><code class=\"language-antlr4\">NEW: 'new';\n</code></pre>\n<p><code>'</code>中就是正規表達式了</p>\n<p>像上面辨識單字的程式可以表示成</p>\n<pre><code class=\"language-antlr4\">WORD: [a-zA-Z]+;\n</code></pre>\n<p><code>[]</code>中是字元集，<code>+</code>表示至少 match 一個</p>\n<p>關於 Lexer，可以算是告一段落，哪天應該會寫一下 Parser 那的技術</p>\n<p>總結一下，我們今天學到的是狀態機的概念與各種常見實作，如果真的弄懂的話，手刻一個自己的 Lexer 應該不是難事，如果有任何疑難都可以在下面留言，我會盡力回答</p>\n<h3>References:</h3>\n<h4><a href=\"https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0\">Engineering a compiler</a></h4>\n<ul>\n<li>Author: Keith D. Cooper &#x26; Linda Torczon</li>\n<li>ISBN: 978-0-12-088478-0</li>\n</ul>\n<h4><a href=\"http://shop.oreilly.com/product/0636920040385.do\">Programming Rust</a></h4>\n<ul>\n<li>Author: Jim Blandy &#x26; Jason Orendorff</li>\n<li>ISBN: 978-1-491-92728-1</li>\n</ul>\n<h4><a href=\"https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811\">Compilers: principles, techniques, and tools: 2E</a></h4>\n<ul>\n<li>Author: Alfred V. Aho &#x26; Monica S. Lam &#x26; Ravi Sethi &#x26; Jeffrey D. Ullman</li>\n<li>ISBN: 978-986-154-936-1(Traditional Chinese Version)</li>\n</ul>\n<script>\n\nd3.select(\"#state_machine_graphic_of_new\")\n  .style(\"background-color\", \"#e8e8e8\")\n  .style(\"font-size\", \"18px\")\n  .append(\"svg\")\nvar svg = d3.select(\"#state_machine_graphic_of_new > svg\");\nfunction newline(svg, x1, y1, x2, y2) {\n  svg\n  .append(\"line\")\n  .attr(\"x1\", x1)\n  .attr(\"y1\", y1)\n  .attr(\"x2\", x2)\n  .attr(\"y2\", y2)\n  .style(\"stroke\", \"black\")\n  .style(\"stroke-width\", \"2px\")\n}\nfunction newcircle(svg, r, x, y, color) {\n  svg.append(\"circle\")\n    .attr(\"r\", r)\n    .attr(\"cx\", x)\n    .attr(\"cy\", y)\n    .style(\"fill\", color)\n}\nfunction newtext(svg, x, y, text) {\n  svg.append(\"text\")\n    .attr(\"x\", x)\n    .attr(\"y\", y)\n    .text(text)\n}\n\nnewtext(svg, 53, 70, \"n\")\nnewline(svg, 30, 80, 90, 80)\n\nnewtext(svg, 115, 70, \"e\")\nnewline(svg, 90, 80, 150, 80)\n\nnewtext(svg, 175, 70, \"w\")\nnewline(svg, 150, 80, 210, 80)\n\nnewcircle(svg, 20, 30, 80, \"gray\")\nnewtext(svg, 18, 88, \"s0\")\n\nnewcircle(svg, 20, 90, 80, \"gray\")\nnewtext(svg, 80, 88, \"s1\")\n\nnewcircle(svg, 20, 150, 80, \"gray\")\nnewtext(svg, 140, 88, \"s2\")\n\nnewcircle(svg, 20, 210, 80, \"red\")\nnewtext(svg, 199, 88, \"s3\")\n</script>","frontmatter":{"title":"Introduction Of Char Recognizing -- Lexer Tech"}}},"pageContext":{"slug":"/blog/cs/introduction-of-char-recognizing-lexer/"}}}