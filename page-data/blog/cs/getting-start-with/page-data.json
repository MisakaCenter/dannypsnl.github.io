{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/getting-start-with/","result":{"data":{"markdownRemark":{"html":"<p>Rust is a strange language.</p>\n<p>Let's start!</p>\n<h2>Moving</h2>\n<p>First point is move semantic.</p>\n<pre><code class=\"language-rust\">fn main() {\n    let s = \"hello\".to_string();\n    let t = s;\n    let u = s;\n}\n</code></pre>\n<p>What do you expect? <code>t</code> &#x26; <code>u</code> is <code>s</code>? No!</p>\n<p><code>rustc</code> says:</p>\n<pre><code>error[E0382]: use of moved value: `s`\n --> main.rs:4:9\n  |\n3 |     let t = s;\n  |         - value moved here\n4 |     let u = s;\n  |         ^ value used here after move\n  |\n  = note: move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait\n</code></pre>\n<p>These error tell you why you got a fail.</p>\n<p>In Rust, you should expect default behavior of assign is moving!</p>\n<h3>Copy</h3>\n<p>And you can expect if any type implement the <code>Copy</code> trait, will be copied.</p>\n<p>That's why these code will work:</p>\n<pre><code class=\"language-rust\">let s = 1;\nlet t = s;\nlet u = s;\n</code></pre>\n<p>Implement the <code>Copy</code> trait can use <code>derive</code> notation in Rust.</p>\n<pre><code class=\"language-rust\">#[derive(Clone, Copy)]\nstruct Foo {\n    number: i32\n}\n</code></pre>\n<p>Notice that <code>Clone</code> is required.</p>\n<p>But a type implement <code>Copy</code> can't have a field do not implement <code>Copy</code>!!!</p>\n<p>So following code will fail.</p>\n<pre><code class=\"language-rust\">#[derive(Clone, Copy)]\nstruct Foo {\n    label: String\n}\n</code></pre>\n<p>Error message:</p>\n<pre><code>error[E0204]: the trait `Copy` may not be implemented for this type\n --> main.rs:1:17\n  |\n1 | #[derive(Clone, Copy)]\n  |                 ^^^^\n2 | struct Foo {\n3 |     number: String,\n  |     -------------- this field does not implement `Copy`\n</code></pre>\n<h2>Mutable</h2>\n<p>In Rust, mutable and immutable is very different.</p>\n<pre><code class=\"language-rust\">let s = \"one \".to_string();\ns.push_str(\"two \");\n</code></pre>\n<p>Error report:</p>\n<pre><code>error[E0596]: cannot borrow immutable local variable `s` as mutable\n --> main.rs:3:5\n  |\n2 |     let s = \"one \".to_string();\n  |         - consider changing this to `mut s`\n3 |     s.push_str(\"two \");\n  |     ^ cannot borrow mutably\n</code></pre>\n<p>Because <code>String::push_str</code> borrow <code>&#x26;mut self</code>, it can't be used by an immutable <code>String</code>.</p>\n<h2>Reference</h2>\n<p>We already seen <code>String</code>, it's called <strong>owning pointer</strong>, others are <code>Vec</code>, <code>Box</code>, etc.</p>\n<p>But these pointer will move data. Sometime, we don't need to moving data, but also don't want to copy it.</p>\n<p>It's reference showtime!</p>\n<p>Rust's reference has some points.</p>\n<ol>\n<li>explicitly using thing it point to</li>\n</ol>\n<pre><code class=\"language-rust\">let a = 1;\nlet r = &#x26;a;\nassert!(*r == 1);\n</code></pre>\n<ol start=\"2\">\n<li>mutable reference to mutable ownership</li>\n</ol>\n<pre><code class=\"language-rust\">let mut num = 15;\nlet r = &#x26;mut num;\n*r += 10;\nassert!(*r == 25);\n</code></pre>\n<ol start=\"3\">\n<li>references are never null</li>\n<li>you can't borrow a value will outlive when you still alive</li>\n</ol>\n<pre><code class=\"language-rust\">let r;\n{\n    let x = 1;\n    r = &#x26;x;\n}\n</code></pre>\n<p>Error message:</p>\n<pre><code>error[E0597]: `x` does not live long enough\n --> main.rs:5:14\n  |\n5 |         r = &#x26;x;\n  |              ^ borrowed value does not live long enough\n6 |     }\n  |     - `x` dropped here while still borrowed\n7 | }\n  | - borrowed value needs to live until here\n</code></pre>\n<p>The problem is <code>r</code> can be access after <code>x</code> already be dropped!\nThat mean a dangling pointer. Rust disallowed it.</p>\n<h2>Conclusion</h2>\n<p>I think these are the most hard part when you're beginner of Rust.</p>\n<p>Because Rust chooses a new way to handle it's memory, move default, checking live-time, sharing data by reference.</p>\n<p>Understanding these things is most important to get familiar with Rust.</p>\n<p>Hope you like it &#x26; can get some help from this.</p>\n<h3>References:</h3>\n<h4><a href=\"http://shop.oreilly.com/product/0636920040385.do\">Programming Rust</a></h4>\n<ul>\n<li>Author: Jim Blandy &#x26; Jason Orendorff</li>\n<li>ISBN: 978-1-491-92728-1</li>\n</ul>","frontmatter":{"title":"How to getting start with Rust"}}},"pageContext":{"slug":"/blog/cs/getting-start-with/"}}}