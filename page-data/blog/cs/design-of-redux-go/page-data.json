{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/design-of-redux-go/","result":{"data":{"markdownRemark":{"html":"<p>Redux is a single flow state manager. I porting it from JS to Go at last year.</p>\n<p>But there had one thing make me can't familiar with it, that is type of state!</p>\n<p>In Redux, we have store combined by many reducers. Then we dispatch action into store to updating our state. That means our state could be anything.</p>\n<p>In JS, we have a reducer like:</p>\n<pre><code class=\"language-javascript\">const counter = (state = 0, action) => {\n    switch action.type {\n    case \"INC\":\n        return state + action.payload\n    case \"DEC\":\n        return state - action.payload\n    default:\n        return state\n    }\n}\n</code></pre>\n<p>It's look good, because we don't have type limit at here. In Redux-go v1, we have:</p>\n<pre><code class=\"language-go\">func counter(state interface{}, action action.Action) interface{} {\n    if state == nil {\n        return 0\n    }\n    switch action.Type {\n    case \"INC\":\n        return state.(int) + action.Args[\"payload\"].(int)\n    case \"DEC\":\n        return state.(int) - action.Args[\"payload\"].(int)\n    default:\n        return state\n    }\n}\n</code></pre>\n<p>Look at those assertion, of course it's safe because you should know which type are you using. But just so ugly.</p>\n<p>So I decide to change this. In v2, we have:</p>\n<pre><code class=\"language-go\">func counter(state int, payload int) int {\n    return state + payload\n}\n</code></pre>\n<p>Wait, what!!!?</p>\n<p>So I have to explain the magic behind it.</p>\n<p>First is how to got user wanted type of state. The answer is <code>reflect</code> package.</p>\n<p>But how? Let's dig in <code>v2/store</code> function: <code>New</code>.</p>\n<pre><code class=\"language-go\">func New(reducers ...interface{}) *Store\n</code></pre>\n<p>As you see, we have to accept any type been a reducer at parameters part.</p>\n<p>Then let's see type: <code>Store</code>(only core part)</p>\n<pre><code class=\"language-go\">type Store struct {\n    reducers []reflect.Value\n    state    map[uintptr]reflect.Value\n}\n</code></pre>\n<p>Yp, we store the reflect result that type is <code>reflect.Value</code>.</p>\n<p>But why? Because if we store <code>interface{}</code>, we have to call <code>reflect.ValueOf</code> each time we want to call it! That will become too slow.</p>\n<p>And <code>state</code> will have an exlpanation later.</p>\n<p>So in the <code>New</code> body.</p>\n<pre><code class=\"language-go\">func New(reducers ...interface{}) *Store {\n    // malloc a new store and point to it\n    newStore := &#x26;Store{\n        reducers: make([]reflect.Value, 0),\n        state:    make(map[uintptr]reflect.Value),\n    }\n    // range all reducers, of course\n    for _, reducer := range reducers {\n        r := reflect.ValueOf(reducer)\n        checkReducer(r)\n        // Stop for while\n    }\n}\n</code></pre>\n<p>Ok, what is <code>checkReducer</code>? Let's take a look now!</p>\n<pre><code class=\"language-go\">func checkReducer(r reflect.Value) {\n    // Ex. nil\n    if r.Kind() == reflect.Invalid {\n        panic(\"It's an invalid value\")\n    }\n\n    // reducer :: (state, action) -> state\n\n    // Missing state or action\n    // Ex. func counter(s int) int\n    if r.Type().NumIn() != 2 {\n        panic(\"reducer should have state &#x26; action two parameter, not thing more\")\n    }\n    // Return mutiple result, Redux won't know how to do with this\n    // Ex. func counter(s int, p int) (int, error)\n    if r.Type().NumOut() != 1 {\n        panic(\"reducer should return state only\")\n    }\n    // Return's type is not input type, Redux don't know how would you like to handle this\n    // Ex. func counter(s int, p int) string\n    if r.Type().In(0) != r.Type().Out(0) {\n        panic(\"reducer should own state with the same type at anytime, if you want have variant value, please using interface\")\n    }\n}\n</code></pre>\n<p>Now back to <code>New</code></p>\n<pre><code class=\"language-go\">// ...\nfor _, reducer := range reducers {\n    // ...\n    checkReducer(r)\n    newStore.reducers = append(newStore.reducers, r)\n\n    newStore.state[r.Pointer()] = r.Call(\n        []reflect.Value{\n            reflect.Zero(r.Type().In(0)),\n            reflect.Zero(r.Type().In(1)),\n        },\n    )[0]\n}\nreturn newStore\n// ...\n</code></pre>\n<p>So that's how <code>state</code> work, using a address of reducer mapping it's state.</p>\n<p><code>reflect.Value.Call</code> this method allow you invoke a <code>reflect.Value</code> from a function.</p>\n<p>It's parameter types required by signature. It always return several <code>refelct.Value</code>, but because we just very sure we only reutrn one thing, so we can just extract index 0.</p>\n<p>Then is <code>state</code>, why I choose to using pointer but not function name this time?</p>\n<p>Thinking about this:</p>\n<pre><code class=\"language-go\">// pkg a\nfunc Reducer(s int, p int) int\n// pkg b\nfunc Reducer(s int, p int) int\n// pkg main\nfunc main() {\n    store := store.New(a.Reducer, b.Reducer)\n}\n</code></pre>\n<p>Which one should we pick? Of course we can trying to left package name make it can be identified.</p>\n<p>But next is the really hard:</p>\n<pre><code class=\"language-go\">func main() {\n    counter := func(s int, p int) int { return s + p }\n    store := store.New(counter)\n}\n</code></pre>\n<p>If you think counter name is counter, that is totally wrong, it's name is <strong>func1</strong>.</p>\n<p>So, I decide using function itself to get mapping state. That is new API: <code>StateOf</code></p>\n<pre><code class=\"language-go\">func (s *Store) StateOf(reducer interface{}) interface{} {\n    place := reflect.Valueof(reducer).Pointer()\n    return s.state[place].Interface()\n}\n</code></pre>\n<p>The point is <code>reflect.Value.Interface</code>, this method return the value it owns.</p>\n<p>The reason we return <code>interface{}</code> at here is because, we have no way to convert to user wanted type, and user is always know what them get actually, just for convience we let user can use any type for their state, so they don't need to do <code>state.(int)</code> these assertion.</p>\n<p>Now, you just work like this:</p>\n<pre><code class=\"language-go\">func main() {\n    counter := func(s int, payload int) int {\n        return s + payload\n    }\n    store := store.New(counter)\n    store.Dispatch(10)\n    store.Dispatch(100)\n    store.Dispatch(-30)\n    fmt.Printf(\"%d\\n\", store.StateOf(counter)) // expected: 80\n}\n</code></pre>\n<p>These are biggest break through for v2, thanks for read</p>","frontmatter":{"title":"Design of Redux-go v2"}}},"pageContext":{"slug":"/blog/cs/design-of-redux-go/"}}}