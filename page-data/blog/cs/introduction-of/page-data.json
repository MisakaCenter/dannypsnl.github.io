{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/introduction-of/","result":{"data":{"markdownRemark":{"html":"<p>今天我想介紹一個強大有趣的工具--ANTLR</p>\n<p>這個工具根據我們定義的文法產生處理原始碼的 parser，當然不只是處理程式語言，你也可以用來處理其他資料</p>\n<h2>安裝</h2>\n<pre><code class=\"language-bash\">cd /usr/local/lib\nsudo curl -O http://www.antlr.org/download/antlr-4.7-complete.jar\nexport CLASSPATH=\".:/usr/local/lib/antlr-4.7-complete.jar:$CLASSPATH\"\nalias antlr4='java -jar /usr/local/lib/antlr-4.7-complete.jar'\nalias grun='java org.antlr.v4.gui.TestRig'\n</code></pre>\n<p>之後會用到的通常是<code>antlr4</code>這支程式</p>\n<p>因為它用來產生 parser</p>\n<h2>開始</h2>\n<p>我們需要建立一個檔案叫<code>xxx.g4</code>，而裡頭的 grammar 就必須是<code>grammar xxx;</code></p>\n<p>舉例來說<code>JSON.g4</code>就會是</p>\n<pre><code class=\"language-antlr4\">grammar JSON;\n</code></pre>\n<p>接下來我們談<code>ANLTR</code>的語法還有它如何運作</p>\n<p>首先如果你接觸過<code>v3</code>以前的<code>antlr</code>，那麼你一定知道<code>embbed action</code></p>\n<p>不過這個版本的<code>antlr</code>並不需要全都使用<code>embbed action</code>來實現程式邏輯</p>\n<p>反之它加入了<code>xxxBaseListener</code>來處理大部分的翻譯過程</p>\n<p>你也可以選擇<code>Visitor</code>來實作，但是<code>visitor</code>需要顯式的調用<code>Context</code>，並不適合大型複雜的文法</p>\n<p><code>Listener</code>則能應付絕大多數的情況，它的<code>API</code>都是<code>enterXxx</code>跟<code>exitXxx</code>的格式，名稱相當直觀</p>\n<h2>約定</h2>\n<p>ANTLR 要求<code>Token</code>使用大寫英文字母開頭，<code>grammar</code>則使用小寫</p>\n<p>例如:</p>\n<pre><code class=\"language-antlr4\">NUM : [0-9]+ ;\nID : [a-z]+ ;\n\nstat : ID '=' expr\n    | expr\n    ;\n\nexpr : NUM\n    | ID\n    ;\n</code></pre>\n<p><code>ID</code>跟<code>NUM</code>都是<code>token</code>，<code>stat</code>跟<code>expr</code>則是文法規則</p>\n<p><code>|</code> 表示不同的可能</p>\n<p><code>;</code> 表示規則結束</p>\n<p>可以看到如果我們想要辨別符號，必須用<code>''</code>包起來，除了符號，關鍵字也要這樣處理，像這樣</p>\n<pre><code class=\"language-antlr4\">Class : 'class' ;\n</code></pre>\n<p><code>+</code> 表示一個或無限多個</p>\n<p><code>*</code> 表示沒有或無限多個</p>\n<p><code>?</code> 表示有或沒有</p>\n<p>定義<code>ID</code>跟<code>NUM</code>時，我都使用了正規表達式來處理，這是為了方便而放入的功能</p>\n<p>你也可以選擇</p>\n<pre><code class=\"language-antlr4\">NUM : ('0' .. '9')+ ;\n</code></pre>\n<p>這種寫法</p>\n<p>最後就是產生<code>parser</code></p>\n<pre><code class=\"language-bash\">antlr4 -Dlanguage=Cpp JSON.g4\n</code></pre>\n<p><code>-Dlanguage</code> 指定產生什麼語言的<code>parser</code></p>\n<p>這裡是<code>C++</code></p>\n<p>如果不指定，那麼預設是<code>Java</code></p>\n<p>目前支援<code>Java</code>, <code>C#</code>, <code>Python2|3</code>, <code>JavaScript</code>, <code>Go</code>, <code>C++</code>, <code>Swift</code></p>\n<p>儘管選擇你習慣的那個</p>\n<p>為什麼要學 Antlr?</p>\n<p>事實上編譯技術在很多地方都有用途</p>\n<p>例如<code>Firefox</code>團隊為了加速<code>JavaScript</code> <code>eval</code>函式的執行速率，在編譯到<code>eval</code>時會進行預處理，讓<code>JavaScript</code>真的執行到這邊時已經少了許多工作</p>\n<p>簡單一些的應用可能有：編寫<code>DSL</code>簡化開發工作</p>\n<p>例如新增網路服務<code>API</code>，如果用特製的語言將工作進行簡化</p>\n<pre><code class=\"language-nim\">routes:\n    get \"/\":\n        resp Page1\n</code></pre>\n<p>那麼我們實際上需要負擔的工作量就大幅縮小了吧！</p>\n<p>而且亦便於未來的維護工作，而<code>DSL</code>最棒的要點就在於，我們往往無須實現完整的通用語言</p>\n<p>比如我們可以在回傳的區塊回到<code>Java</code>語言</p>\n<pre><code class=\"language-nim\">routes:\n    get \"/\":\n        @java {\n            // ... Your java code\n        }\n</code></pre>\n<p>這樣我們就不需要實現太過麻煩的東西</p>\n<p>而一樣能享受<code>DSL</code>的方便度</p>","frontmatter":{"title":"ANTLR v4--introduction"}}},"pageContext":{"slug":"/blog/cs/introduction-of/"}}}