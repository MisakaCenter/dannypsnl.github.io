{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/kube-client-go-source-code/","result":{"data":{"markdownRemark":{"html":"<p>Whole thing is started from <strong>Ingress</strong> this feature of <strong>Kubernetes</strong>.\nBut today I'm not going to talk too much about it, basically just I have to let <strong>Ingress Controller</strong>\nwill send packets to our <strong>Router</strong> so that we could do the thing we want,\nif you are interested in our <strong>Router</strong>, you can more infos from <a href=\"https://glasnostic.com/blog\">our blog</a> and\ndemo by just login to play with it.</p>\n<p>Anyway, the thing I'm going to do for this is I have to create a proxy for real kubernetes API server,\nand modify the real data to what we want. To do that, I have to understand how <a href=\"https://github.com/kubernetes/client-go\">client-go</a>\n(<strong>Ingress</strong> use client-go to get info, of course) send requests and what it expected. Let's start!</p>\n<blockquote>\n<p>NOTE: I just mention some part of codes, not explaining whole big piture</p>\n</blockquote>\n<pre><code class=\"language-go\">    epEventHandler := cache.ResourceEventHandlerFuncs{\n        AddFunc: func(obj interface{}) {\n            updateCh.In() &#x3C;- Event{\n                Type: CreateEvent,\n                Obj:  obj,\n            }\n        },\n        DeleteFunc: func(obj interface{}) {\n            updateCh.In() &#x3C;- Event{\n                Type: DeleteEvent,\n                Obj:  obj,\n            }\n        },\n        UpdateFunc: func(old, cur interface{}) {\n            oep := old.(*corev1.Endpoints)\n            cep := cur.(*corev1.Endpoints)\n            if !reflect.DeepEqual(cep.Subsets, oep.Subsets) {\n                updateCh.In() &#x3C;- Event{\n                    Type: UpdateEvent,\n                    Obj:  cur,\n                }\n            }\n        },\n    }\n</code></pre>\n<p>These codes at <a href=\"https://github.com/kubernetes/ingress-nginx\">ingress-nginx</a> tag <code>nginx-v0.20.0</code>(at following context we just use this tag),\nfile <code>internal/ingress/controller/store/store.go</code> line <code>446</code></p>\n<p>The purpose is emit these callbacks into <code>SharedInformer</code> to get kubernetes events for updating the datas in store,\nto generate nginx configuration for load balancing these pods.</p>\n<p>Ok, so where we use <code>epEventHandler</code>? We would see it be passed into <code>store.informers.Endpoint</code> at\nthe same function, line <code>519</code></p>\n<pre><code class=\"language-go\">store.informers.Endpoint.AddEventHandler(epEventHandler)\n</code></pre>\n<p>Here we should care two things</p>\n<ul>\n<li>what is <code>Endpoint</code>?</li>\n<li>how it use the functions sent into <code>AddEventHandler</code>?</li>\n</ul>\n<p>Let's keep dig into the code, we would see <code>AddEventHandler</code> is a method of an <code>interface</code>: <code>SharedInformer</code>,\nyes, we just talk about it, now we see it. <code>SharedInformer</code> is defined under <code>k8s.io/client-go/tools/cache/shared_informer.go</code>\n(remember, here what I'm tracing is the <code>client-go</code> under <code>ingress-nginx</code> vendor, so it might outdate with latest <code>client-go</code>)</p>\n<p>The only implementor of <code>SharedInformer</code> is <code>sharedIndexInformer</code>(still at same file),\nit's a structure, here is the real code of <code>AddEventHandler</code></p>\n<pre><code class=\"language-go\">func (s *sharedIndexInformer) AddEventHandler(handler ResourceEventHandler) {\n    s.AddEventHandlerWithResyncPeriod(handler, s.defaultEventHandlerResyncPeriod)\n}\n\nfunc (s *sharedIndexInformer) AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) {\n    // ignore, here would do some period syncing\n    listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)\n    // ignore, here would emit `listener` into `processer`\n}\n\nfunc newProcessListener(handler ResourceEventHandler, requestedResyncPeriod, resyncPeriod time.Duration, now time.Time, bufferSize int) *processorListener {\n    ret := &#x26;processorListener{\n        nextCh:                make(chan interface{}),\n        addCh:                 make(chan interface{}),\n        handler:               handler,\n        pendingNotifications:  *buffer.NewRingGrowing(bufferSize),\n        requestedResyncPeriod: requestedResyncPeriod,\n        resyncPeriod:          resyncPeriod,\n    }\n\n    ret.determineNextResync(now)\n\n    return ret\n}\n</code></pre>\n<p>To here, we should stop this part, because we can't get more from these.\nSo I go back to how to use <code>sharedIndexInformer</code></p>\n<p>I found type of <code>store.informers</code> have a method <code>Run</code> that would be called by store,\nthat's mean what it call is the point we care, that's <code>store.informers.Endpoint</code></p>\n<pre><code class=\"language-go\">func (i *Informer) Run(stopCh chan struct{}) {\n    // this is *sharedIndexInformer.Run\n    go i.Endpoint.Run(stopCh)\n    // ignore, all resource is working under the same way\n}\n\nfunc (s *sharedIndexInformer) Run(stopCh &#x3C;-chan struct{}) {\n    // this is last line, I ignore others codes\n    s.controller.Run(stopCh)\n}\n</code></pre>\n<p>Then I take a look at how controller works</p>\n<pre><code class=\"language-go\">// Run begins processing items, and will continue until a value is sent down stopCh.\n// It's an error to call Run more than once.\n// Run blocks; call via go.\nfunc (c *controller) Run(stopCh &#x3C;-chan struct{}) {\n    defer utilruntime.HandleCrash()\n    go func() {\n        &#x3C;-stopCh\n        c.config.Queue.Close()\n    }()\n    r := NewReflector(\n        c.config.ListerWatcher,\n        c.config.ObjectType,\n        c.config.Queue,\n        c.config.FullResyncPeriod,\n    )\n    r.ShouldResync = c.config.ShouldResync\n    r.clock = c.clock\n\n    c.reflectorMutex.Lock()\n    c.reflector = r\n    c.reflectorMutex.Unlock()\n\n    var wg wait.Group\n    defer wg.Wait()\n\n    wg.StartWithChannel(stopCh, r.Run)\n\n    wait.Until(c.processLoop, time.Second, stopCh)\n}\n</code></pre>\n<p>The point is <code>wg.StartWithChannel(stopCh, r.Run)</code>, in <code>reflector.Run</code>,\nit call <code>r.ListAndWatch(stopCh)</code>, and <code>ListAndWatch</code> is based on <code>listWatcher</code></p>\n<pre><code class=\"language-go\">list, err := r.listerWatcher.List(options)\nif err != nil {\n    return fmt.Errorf(\"%s: Failed to list %v: %v\", r.name, r.expectedType, err)\n}\n</code></pre>\n<p>We would go back here later, let's find out what is <code>listerWatcher</code></p>\n<p>We set <code>store.informers.Endpoint</code> by this <code>store.informers.Endpoint = infFactory.Core().V1().Endpoints().Informer()</code> at\n<code>internal/ingress/controller/store/store.go:L264</code></p>\n<p>Then we see <code>infFactory</code>, line <code>257</code></p>\n<pre><code class=\"language-go\">infFactory := informers.NewSharedInformerFactoryWithOptions(client, resyncPeriod,\n    informers.WithNamespace(namespace),\n    informers.WithTweakListOptions(func(*metav1.ListOptions) {}))\n</code></pre>\n<p><code>informer</code>:</p>\n<pre><code class=\"language-go\">func (f *endpointsInformer) Informer() cache.SharedIndexInformer {\n    return f.factory.InformerFor(&#x26;corev1.Endpoints{}, f.defaultInformer)\n}\n// defaultInformer\nfunc (f *endpointsInformer) defaultInformer(client kubernetes.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {\n    return NewFilteredEndpointsInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)\n}\n// NewFilteredEndpointsInformer\nfunc NewFilteredEndpointsInformer(client kubernetes.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {\n    return cache.NewSharedIndexInformer(\n        &#x26;cache.ListWatch{\n            ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {\n                if tweakListOptions != nil {\n                    tweakListOptions(&#x26;options)\n                }\n                return client.CoreV1().Endpoints(namespace).List(options)\n            },\n            WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n                if tweakListOptions != nil {\n                    tweakListOptions(&#x26;options)\n                }\n                return client.CoreV1().Endpoints(namespace).Watch(options)\n            },\n        },\n        &#x26;corev1.Endpoints{},\n        resyncPeriod,\n        indexers,\n    )\n}\n</code></pre>\n<p>Ha, we got <code>ListWatch</code> now, it would call an instance of <code>*kubernetes.ClientSet</code> to get the info it wanted!</p>\n<p>Now we can back to <code>ListAndWatch</code>, let's take a look at the details of it.</p>\n<p>In fact, I'm more focused on watch API, because it's a little bit weird.\nI found it's server with keep sending data until client part close the connection.\nHow it did it? At <code>k8s.io/client-go/tools/cache/reflector.go:L226</code></p>\n<pre><code class=\"language-go\">    for {\n        // give the stopCh a chance to stop the loop, even in case of continue statements further down on errors\n        select {\n        case &#x3C;-stopCh:\n            return nil\n        default:\n        }\n\n        timeoutSeconds := int64(minWatchTimeout.Seconds() * (rand.Float64() + 1.0))\n        options = metav1.ListOptions{\n            ResourceVersion: resourceVersion,\n            // We want to avoid situations of hanging watchers. Stop any wachers that do not\n            // receive any events within the timeout window.\n            TimeoutSeconds: &#x26;timeoutSeconds,\n        }\n\n        r.metrics.numberOfWatches.Inc()\n        w, err := r.listerWatcher.Watch(options)\n        if err != nil {\n            switch err {\n            case io.EOF:\n                // watch closed normally\n            case io.ErrUnexpectedEOF:\n                glog.V(1).Infof(\"%s: Watch for %v closed with unexpected EOF: %v\", r.name, r.expectedType, err)\n            default:\n                utilruntime.HandleError(fmt.Errorf(\"%s: Failed to watch %v: %v\", r.name, r.expectedType, err))\n            }\n            // If this is \"connection refused\" error, it means that most likely apiserver is not responsive.\n            // It doesn't make sense to re-list all objects because most likely we will be able to restart\n            // watch where we ended.\n            // If that's the case wait and resend watch request.\n            if urlError, ok := err.(*url.Error); ok {\n                if opError, ok := urlError.Err.(*net.OpError); ok {\n                    if errno, ok := opError.Err.(syscall.Errno); ok &#x26;&#x26; errno == syscall.ECONNREFUSED {\n                        time.Sleep(time.Second)\n                        continue\n                    }\n                }\n            }\n            return nil\n        }\n\n        if err := r.watchHandler(w, &#x26;resourceVersion, resyncerrc, stopCh); err != nil {\n            if err != errorStopRequested {\n                glog.Warningf(\"%s: watch of %v ended with: %v\", r.name, r.expectedType, err)\n            }\n            return nil\n        }\n    }\n</code></pre>\n<p>Of course is a endless loop, would stop by channel or return.</p>\n<p>The tricky part is it check error content, if it's a probable EOF, it would keep taking data rather stop connection.</p>\n<p>Ok, everything seems make sense right now, but that's not enough, I'm very confused by why it could receiving a JSON data by\nsuch as a streaming way, so let's go back to see <code>client.CoreV1().Endpoints(namespace).Watch(options)</code></p>\n<pre><code class=\"language-go\">// Watch returns a watch.Interface that watches the requested endpoints.\nfunc (c *endpoints) Watch(opts metav1.ListOptions) (watch.Interface, error) {\n    opts.Watch = true\n    return c.client.Get().\n        Namespace(c.ns).\n        Resource(\"endpoints\").\n        VersionedParams(&#x26;opts, scheme.ParameterCodec).\n        Watch()\n}\n// Watch attempts to begin watching the requested location.\n// Returns a watch.Interface, or an error.\nfunc (r *Request) Watch() (watch.Interface, error) {\n    return r.WatchWithSpecificDecoders(\n        func(body io.ReadCloser) streaming.Decoder {\n            framer := r.serializers.Framer.NewFrameReader(body)\n            return streaming.NewDecoder(framer, r.serializers.StreamingSerializer)\n        },\n        r.serializers.Decoder,\n    )\n}\n</code></pre>\n<p>And I found the point is <code>r.serializers</code>, and the shit thing is it still is a function send by external code.</p>\n<p>If you trace back then you would find it's from <code>*RESTClient.serializers</code>,\nat <code>k8s.io/client-go/rest/client.go</code>, line <code>225</code> and <code>227</code> send this into <code>NewRequest</code></p>\n<p>And you found it's created at line <code>108</code> in same file, <code>serializers, err := createSerializers(config)</code></p>\n<pre><code class=\"language-go\">func createSerializers(config ContentConfig) (*Serializers, error) {\n    // ignore, we don't care them since we just use `StreamSerializer` of `Serializers`\n    if info.StreamSerializer != nil {\n        s.StreamingSerializer = info.StreamSerializer.Serializer\n        s.Framer = info.StreamSerializer.Framer\n    }\n\n    return s, nil\n}\n</code></pre>\n<p>We would see the type of <code>StreamSerializer</code> is <code>runtime.Serializer</code>, it's an interface, and since we are sending JSON data,\nso we go to the JSON one implementor of it to see it's <code>Decode</code></p>\n<pre><code class=\"language-go\">import (\n    jsoniter \"github.com/json-iterator/go\"\n)\n</code></pre>\n<p>After see that, I know the trace already done, because my question already been answered, them use <code>github.com/json-iterator/go</code> this library</p>\n<p>I guess I would talk about something about how to create a kube API proxy with modifying datas after completing my proxy of kube API server.\n(It's really hard XD)</p>\n<p>I guess today the most interesting thing we learned is Go <code>*http.Response</code> is a <code>ReadCloser</code>!(How Kubernetes done their watch trick)</p>\n<p>Anyway, thanks for read, hope these could help you more detailed understanding Kubernetes client implementation\nand be a little start point to read more about it.</p>","frontmatter":{"title":"Tracing source code of Kubernetes client-go"}}},"pageContext":{"slug":"/blog/cs/kube-client-go-source-code/"}}}