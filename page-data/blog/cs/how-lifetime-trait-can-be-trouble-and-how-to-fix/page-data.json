{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/how-lifetime-trait-can-be-trouble-and-how-to-fix/","result":{"data":{"markdownRemark":{"html":"<p>In my case, I have a trait called <code>Resource</code> for deserialize from bytes. Now I want to reuse a struct called <code>List</code> for others <code>Resource</code> so I write done:</p>\n<pre><code class=\"language-rust\">struct List&#x3C;T> {\n    // ignore others field\n    items: Vec&#x3C;T>,\n}\n\nimpl&#x3C;T: Resource> Resource for List&#x3C;T> {\n    fn from_str(s: &#x26;str) -> Result&#x3C;List&#x3C;T>> {\n        let list: List&#x3C;T> = serde_json::from_str(s)?;\n        Ok(list);\n    }\n}\n</code></pre>\n<p>Because <code>serde_json::from_str</code> requires <code>impl Deserialize</code> so we have to modify the code:</p>\n<pre><code class=\"language-rust\">impl&#x3C;T: Resource + Deserialize> Resource for List&#x3C;T> {\n    fn from_str(s: &#x26;str) -> Result&#x3C;List&#x3C;T>> {\n        let list: List&#x3C;T> = serde_json::from_str(s)?;\n        Ok(list);\n    }\n}\n</code></pre>\n<p>It looks work but not. The problem is <code>Deserialize</code> actually is <code>Deserialize&#x3C;'de></code>, when we use the trait in the declaration we have to satisfy all type parameters of course includes lifetime. Ok, so we write:</p>\n<pre><code class=\"language-rust\">impl&#x3C;'a, T: Resource + Deserialize&#x3C;'a>> Resource for List&#x3C;T> {\n    fn from_str(s: &#x26;'a str) -> Result&#x3C;List&#x3C;T>> {\n        let list: List&#x3C;T> = serde_json::from_str(s)?;\n        Ok(list);\n    }\n}\n</code></pre>\n<p>It looks good and works for most cases actually, however, in my code I hiding the whole get data and deserialize in a function, whatever it's, would cause a problem.</p>\n<pre><code class=\"language-rust\">fn get_list_via_fetching_data&#x3C;'a, T: Deserialize&#x3C;'a>>() -> Result&#x3C;List&#x3C;T>> {\n    let data = fetch(); // in my case is kubernetes api server but that's fine\n    List::&#x3C;T>::from_str(data)\n}\n</code></pre>\n<p>Ok, you would find <code>data</code> is not live long enough for <code>'a</code>, why? Since anyway <code>'a</code> would be an outside lifetime and of course, live longer than anything in the function. What can we do for this case? We have to reverse the relationship between others <code>Resource</code> and <code>List</code>, rather than see <code>List</code> as kind of <code>Resource</code>, we add a function <code>fn from_str_to_list(s: &#x26;str) -> Result&#x3C;List&#x3C;Self>>;</code> for trait <code>Resource</code>. Since in my case <code>Resource</code> impl <code>Sized</code> and <code>List</code> also has a detected size after applying a <code>Sized T</code> so <code>List&#x3C;Self></code> is <code>Sized</code>. Now we can have the function <code>get_list_via_fetching_data</code>.</p>\n<p>Of course, for the most normal case I think we don't need this one, and if at future <code>'_</code> lifetime introduced the problem could be resolved(but I'm not sure that is for this problem actually so just a guess).</p>\n<p>Thanks for reading and see you next time.</p>","frontmatter":{"title":"How trait with lifetime can be a trouble and how to fix it"}}},"pageContext":{"slug":"/blog/cs/how-lifetime-trait-can-be-trouble-and-how-to-fix/"}}}