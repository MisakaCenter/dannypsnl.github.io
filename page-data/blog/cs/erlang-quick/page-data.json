{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/erlang-quick/","result":{"data":{"markdownRemark":{"html":"<p>那麼今天就來介紹說很久但是一直沒有寫的 Erlang 吧!</p>\n<p>Erlang 是一隻很有趣的語言，它絕對跟你看過的主流語言有巨大的差異，無論是語法上還是思想上皆是如此</p>\n<p>首先我們需要安裝環境，請參考官方的 Downloads</p>\n<p>接著我們就從 erl 開始吧</p>\n<pre><code class=\"language-bash\">$ erl\n</code></pre>\n<p>輸入指令啟動 Erlang 的互動環境</p>\n<p>你可以先嘗試輸入</p>\n<pre><code class=\"language-erlang\">1> X=0.\n0\n2> X=1.\n** exception error: no match of right hand side value 1\n</code></pre>\n<p>為什麼會出現例外呢？因為 Erlang 不準改變變數之值，Erlang 將<code>X=0.</code>這樣的述句稱為綁定，而變數一但綁定就不能再次綁定，所以 X 將永遠為 0，請不要害怕這會成為問題</p>\n<p>事實上，在共時編程中，這樣的結果是令人安心的，競態問題將大幅減少，你將得到的是助益</p>\n<p>那麼我們來看更加細節的部份，首先變數名稱並不是能隨意命名的，在 Erlang 中，只有大寫開頭的名稱會被當成變數名稱，因為小寫被原子(atom)佔去了(小寫開頭即為原子，後面再解釋何為原子)</p>\n<p>綁定只有一次，.是一個述句的結束</p>\n<p>接著我們來看更多的案例</p>\n<pre><code class=\"language-erlang\">3> X + 20.\n20\n</code></pre>\n<p>就是個加法</p>\n<pre><code class=\"language-erlang\">4> 0 = X.\n0\n5> 1 = X.\n** exception error: no match of right hand side value 0\n</code></pre>\n<p>和剛才稍有不同，不過你可以從這個案例看出為什麼叫做綁定，因為這是雙向的，=會比較兩邊是否相同，如果左值尚未被綁定就會進行綁定行為</p>\n<pre><code class=\"language-erlang\">8> X = 1-1.\n0\n</code></pre>\n<p>這裡有更有趣的案例，你可以更清楚的了解到=的行為</p>\n<pre><code class=\"language-erlang\">9> 4/2.\n2.0\n10> 3/2.\n1.5\n11> 1/3.\n0.3333333333333333\n</code></pre>\n<p>這裡可以看到 Erlang 對數字型別的自動轉換，運算在 Erlang 中相當輕鬆，Erlang 已處理了最麻煩的部份</p>\n<pre><code class=\"language-erlang\">17> hello.\nhello\n</code></pre>\n<p>原子之值即自己</p>\n<pre><code class=\"language-erlang\">18> O = {0, 0}.\n{0,0}\n</code></pre>\n<p>元組(tuple)可以想成匿名的 C 結構</p>\n<p>由於神奇的模式綁定(其實就是=的規則)，我們可以寫出如</p>\n<pre><code class=\"language-erlang\">19> Me = {person, {name, \"Danny\"}, {height, 160}, {sex, male}}.\n{person,{name,\"Danny\"},{height,160},{sex,male}}\n20> {person, {name, MyName}, _ , _} = Me.\n{person,{name,\"Danny\"},{height,160},{sex,male}}\n21> MyName.\n\"Danny\"\n</code></pre>\n<p>這樣複雜的對應式，_匹配任意值但是我們不 care 那是什麼，可以看到我們透過綁定取得 MyName，話說我是不是寫太矮了(咦)</p>\n<p>這裡也展示 Erlang 常用的技巧，利用 atom 標記欄位</p>\n<p>需要注意的是如果右值具有不存在的參考，Erlang 會說明此參考尚未繫結(unbound)</p>\n<pre><code class=\"language-erlang\">22> C = A.\n* 1: variable 'A' is unbound\n</code></pre>\n<p>就像這樣</p>\n<p>列表(list)</p>\n<pre><code class=\"language-erlang\">24> A = [1, 2, 3].\n[1,2,3]\n25> [F, _, _] = A.\n[1,2,3]\n26> F.\n1\n</code></pre>\n<p>可以看到列表與結構皆能做模式比對</p>\n<p>差別在於這個案例</p>\n<pre><code class=\"language-erlang\">30> [H|T] = A.\n[1,2,3]\n31> H.\n1\n32> T.\n[2,3]\n</code></pre>\n<p>你可以透過特殊的語法比對出 Head 與 Tail，熟悉函數式編程的同學應該已經興奮不已了吧，大概啦</p>\n<p>這個特性讓 list 能夠被迭代，而 tuple 不能</p>\n<p>接著我們來談字串</p>\n<pre><code class=\"language-erlang\">35> Name = \"Hello\".\n\"Hello\"\n36> Name.\n\"Hello\"\n</code></pre>\n<p>看起來與你過去所學無異，但其實 Erlang 是用數字列表代表字串的，所以你可以</p>\n<pre><code class=\"language-erlang\">37> [83, 117, 114, 112, 114, 105, 115, 101].\n\"Surprise\"\n</code></pre>\n<p>這真的很 Surprise</p>\n<p>但是如果列表無法組成字串，就只是普通的列表，算是 Erlang 中最難搞的陷阱之一</p>\n<p>最後教你怎麼退出<code>erl</code></p>\n<p>輸入<code>q().</code></p>\n<pre><code class=\"language-erlang\">38> q().\nok\n39>\n</code></pre>\n<p>像這樣，這會頓一下才退出</p>\n<p>你也可以按<code>&#x3C;C-c></code>，輸入<code>a</code>，按<code>&#x3C;Enter> (a)bort</code></p>\n<pre><code class=\"language-erlang\">1>\nBREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded\n       (v)ersion (k)ill (D)b-tables (d)istribution\na\n</code></pre>\n<p>像這樣</p>\n<p>按<code>&#x3C;C-g></code>，輸入<code>q</code>，按<code>&#x3C;Enter></code></p>\n<pre><code class=\"language-erlang\">1>\nUser switch command\n --> q\n</code></pre>\n<p>像這樣</p>\n<p>輸入<code>halt().</code></p>\n<pre><code class=\"language-erlang\">1> halt().\n</code></pre>\n<p>像這樣，這會馬上退出</p>\n<p>下一篇介紹模組好了，我到底欠幾個下一篇了 QQ</p>\n<h3>References:</h3>\n<h4><a href=\"https://pragprog.com/book/jaerlang2/programming-erlang\">Programming Erlang: 2ed</a></h4>\n<ul>\n<li>Author: Joe Armstrong</li>\n<li>ISBN: 978-1-93778-553-6</li>\n</ul>","frontmatter":{"title":"Erlang Quick Start"}}},"pageContext":{"slug":"/blog/cs/erlang-quick/"}}}