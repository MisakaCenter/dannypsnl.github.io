{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/golang-concurrency-bug-i/","result":{"data":{"markdownRemark":{"html":"<p>There is a saying:</p>\n<blockquote>\n<p>I never had a slice of bread particularly large and wide that did not fall upon the floor and always on the buttered side</p>\n</blockquote>\n<p>Even I already work with Go for almost 3 years, I still made these stupid bugs.\nBut learning from errors is why we are professional enigneer.\nSo I'm going to list the bug I made, and show how to avoid it.</p>\n<h3>1 select with generator</h3>\n<pre><code class=\"language-go\">func events() &#x3C;-chan int {\n    ch := make(chan int)\n    go func() {\n        for {\n            ch &#x3C;- 1\n        }\n    }()\n    return ch\n}\n\nfunc main() {\n    for {\n        select {\n        case i := &#x3C;- events():\n            println(\"i=\", i)\n        }\n    }\n}\n</code></pre>\n<p>We using a common generator pattern here, and <code>select</code> also is quite normal case, the problem at here is select would call <code>events</code> not just once!\nThis loop would create new channel for every <code>case</code> statement! And leaving infinite go-routine that nobody care!</p>\n<p>To avoid the problem, you have to using <code>range</code>:</p>\n<pre><code class=\"language-go\">func main() {\n    for i := range events() {\n        // ...\n    }\n}\n</code></pre>\n<p>But if you want to stop this looping, which means you still need to use <code>select</code>, then store the channel to other place is required.\nThere are many ways to do that:</p>\n<ul>\n<li>\n<p>In structure:</p>\n<pre><code class=\"language-go\">type eventGenerator struct {\n  eventCh chan int\n  ctx     context.Context\n  cancel  context.CancelFunc\n}\n\nfunc NewEventGenerator(ctx context.Context) *eventGenerator {\n  // better to get context from others place, even this is a most up level controller\n  // because you can use `context.Background()` as argument if this is the most up level one\n  ctx, cancel := context.WithCancel(ctx)\n  return &#x26;eventGenerator{\n      // don't forget to `make` a channel,\n      // if you skip it, Go won't give you any warning\n      // And anything you try to send to it would be ignored!\n      // No Warning!\n      eventCh: make(chan int),\n      ctx: ctx,\n      cancel: cancel,\n  }\n}\n\nfunc (e *eventGenerator) Start() {\n  go func() {\n      defer close(e.eventCh)\n      for {\n          select {\n          case _, closed := &#x3C;- e.ctx.Done():\n              if closed {\n                  return\n              }\n          default:\n              e.eventCh &#x3C;- 1\n          }\n      }\n  }()\n}\nfunc (e *eventGenerator) Events() &#x3C;-chan int { return e.eventCh }\nfunc (e *eventGenerator) Close() { e.cancel() }\n</code></pre>\n<p>Now you can write <code>case &#x3C;-eg.Events():</code> as you want after calling <code>eg.Start()</code> and stop it by <code>eg.Close()</code></p>\n</li>\n<li>\n<p>generator with outside channel</p>\n<pre><code class=\"language-go\">func genEvents(ch chan int) {\n  go func() {\n      for {\n          ch &#x3C;- 1\n      }\n  }()\n}\nfunc main() {\n  d := time.Now().Add(50 * time.Millisecond)\n  ctx, cancel := context.WithDeadline(ctx, d)\n  defer cancel()\n  ch := make(chan int)\n  genEvents(ch)\n  for {\n      select {\n      case i := &#x3C;-ch:\n          println(\"i=\", i)\n      case &#x3C;-ctx.Done():\n          println(\"main:\", ctx.Err().Error())\n          close(ch)\n          return\n      }\n  }\n}\n</code></pre>\n</li>\n</ul>\n<h3>2 misuse context.Done()</h3>\n<p>Let's assuming there is a <code>epoll</code> like function call <code>recv()</code>, you would get something from it and deal with it, but it's not based on channel,\nwhich means you can't use it as <code>case</code> of <code>select</code>, how to deal with it?</p>\n<pre><code class=\"language-go\">func handlingRecv(ctx context.Context) &#x3C;-chan interface{} {\n    ch := make(chan interface{})\n    go func() {\n    defer close(ch)\n        for {\n            data := recv()\n            var v interface{}\n            err := json.Unmarshal(data, v)\n            // ignore error handing\n            ch &#x3C;- v\n\n            select {\n            case _, closed := &#x3C;-ctx.Done():\n                return\n            }\n        }\n    }()\n    return ch\n}\n</code></pre>\n<p>Code looks good? No, in fact the <code>select</code> would be blocked until this context be canceled,\nwhich means you can only get one message from <code>recv()</code>, and no warning, looks like a <strong>NICE</strong> networking problem,\nbut it's a bug of code actually.</p>\n<p>This bug is easy to fix, in fact, easier than previous one a lot.</p>\n<pre><code>select {\ncase _, closed := &#x3C;-ctx.Done():\n    return\ndefault:\n    // move job to here\n}\n</code></pre>\n<p>So easy, we just based on the fact, if no case in, it would do <code>default</code> block work</p>\n<h3>Conculsion</h3>\n<p>The bug show here might be is not hard to solve, but since everything could go wrong would go wrong,\nI still wrote it done and if it's helpful that would be so great. Thanks for read.</p>","frontmatter":{"title":"The Go concurrency bug I made"}}},"pageContext":{"slug":"/blog/cs/golang-concurrency-bug-i/"}}}