{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/cpp-thread/","result":{"data":{"markdownRemark":{"html":"<p>使用標準庫的 thread 非常容易</p>\n<pre><code class=\"language-c++\">#include &#x3C;thread>\n#include &#x3C;iostream>\n\nusing std::cout;\n\nvoid hello() {\n    cout &#x3C;&#x3C; \"hello\" &#x3C;&#x3C; '\\n';\n}\n\nint main()\n{\n    std::thread t(hello);\n    t.join();\n}\n</code></pre>\n<p>1.引入<code>thread</code>標頭檔</p>\n<p>2.宣告函式</p>\n<p>3.建構一個<code>thread</code>物件</p>\n<p>4.用<code>join</code>讓<code>main</code>等待它完成</p>\n<p>很好，程式應該會運作，可是我們想要知道如何傳入參數，對吧!</p>\n<pre><code class=\"language-c++\">void hello(int i) {\n    cout &#x3C;&#x3C; \"hello, \" &#x3C;&#x3C; i &#x3C;&#x3C; '\\n';\n}\n</code></pre>\n<p>所以函數的宣告式自然要改</p>\n<p>但是我們不能直接寫</p>\n<pre><code class=\"language-c++\">std::thread t(hello(2));\n</code></pre>\n<p>因為這不會傳入函數，而是傳函數的結果，那不是我們需要的東西</p>\n<p>正確的寫法是</p>\n<pre><code class=\"language-c++\">std::thread t(hello, 2);\n</code></pre>\n<p>可以輕鬆的從這個實作(Mingw 版本)中看出參數怎麼傳進去的</p>\n<pre><code class=\"language-c++\">template&#x3C;class Function, class... Args>\nexplicit thread(Function&#x26;&#x26; f, Args&#x26;&#x26;... args)\n{\n    typedef decltype(std::bind(f, args...)) Call;\n    Call* call = new Call(std::bind(f, args...));\n    mHandle = (HANDLE)_beginthreadex(NULL, 0, threadfunc&#x3C;Call>,\n        (LPVOID)call, 0, (unsigned*)&#x26;(mThreadId.mId));\n    if (mHandle == _STD_THREAD_INVALID_HANDLE)\n    {\n        int errnum = errno;\n        delete call;\n        throw std::system_error(errnum, std::generic_category());\n    }\n}\n</code></pre>\n<p>事實上，我們不只能傳入函數給 Thread，我們可以傳任何可呼叫(callable)物件進去</p>\n<p>用法非常簡單，就是定義一個具有 operator()的 class，然後用這個 class 產生物件</p>\n<pre><code class=\"language-c++\">class Ya {\npublic:\n    void operator()() const {\n        cout &#x3C;&#x3C; \"Ya\" &#x3C;&#x3C; '\\n';\n    }\n};\n</code></pre>\n<p>就像這樣</p>\n<pre><code class=\"language-c++\">std::thread t( Ya() );\n</code></pre>\n<p>我們用原本的寫法，卻發現編譯失敗，原來是因為這個寫法被編譯器當作函式宣告，而不是一個物件定義</p>\n<p>好吧!怎麼處理?</p>\n<p>第一種作法:加上括號</p>\n<pre><code class=\"language-c++\">std::thread t( (Ya()) );\n</code></pre>\n<p>第二種作法:用大括號初始運算子</p>\n<pre><code class=\"language-c++\">std::thread t{ Ya() };\n</code></pre>\n<p>第二種作法自然必較好，因為符合新的標準(用大括號是官方推薦寫法)，而且很直觀</p>\n<p>第一種作法則讓人難以理解為什麼這樣就可以</p>\n<p>再介紹一種作法</p>\n<pre><code class=\"language-c++\">std::thread t3([] {\n    cout &#x3C;&#x3C; \"lambda\" &#x3C;&#x3C; '\\n';\n});\n</code></pre>\n<p>利用<code>lambda</code>運算式，不過就算是用<code>lambda</code>我也認為應該用大括號運算子，畢竟，沒什麼道理不用擺明用來初始化的大括號(我是說，除了那個該死的<code>auto array</code>狀況，還有字串字面值是<code>const char *</code>)</p>\n<p>那麼<code>join</code>呢?</p>\n<p><code>thread</code>物件一旦建立，啟動執行緒，你就要明確的決定要</p>\n<p>1.等待執行緒結束(<code>join</code>)</p>\n<p>2.讓它自己旁邊玩沙(<code>deatch</code>)</p>\n<p>如果沒有在 thread 物件被清除之前決定，那程式就會終止</p>\n<p>因為</p>\n<pre><code class=\"language-c++\">~thread()\n{\n    if (joinable())\n        std::terminate();\n}\n</code></pre>\n<p>解構子會呼叫<code>std::terminate()</code>讓程式掛掉(如果沒有改變可連結狀態)</p>\n<pre><code class=\"language-c++\">bool joinable() const {return mHandle != _STD_THREAD_INVALID_HANDLE;}\n</code></pre>\n<p>這是<code>joinable</code>的實作，因為名稱取的很好，所以可以看出只要 thread 狀態沒有被合法的處理(上面兩個狀況，<code>join</code>與<code>detach</code>)，就會回傳<code>true</code>，在適當的時候引發<code>terminate</code></p>\n<p>所以即使發生例外，也要確保執行緒成功被決定要怎樣處理</p>\n<p>從這裡應該很容易看出來，<code>thread</code>物件可不是<code>thread</code>本身，而是持有者，所以千萬不要搞混它們的意義</p>\n<p>要讓程式掛掉真的很容易</p>\n<pre><code class=\"language-c++\">std::thread t( hello, i );\n</code></pre>\n<p>不決定的結果就是程式<code>panic</code></p>\n<p>例外!!!</p>\n<p>沒錯，什麼程式遇不到例外，執行緒程式也不例外，前面我們提到，如果沒有決定如何處理<code>thread</code>物件，程式就會掛掉</p>\n<p>很好，那麼遇到例外時怎麼辦?</p>\n<p>第一種辦法很土，不過反正能解決問題就是了</p>\n<pre><code class=\"language-c++\">std::thread t(hello);\ntry {\n    // ...\n} catch (int err) {\n    t.join();\n}\nt.join();\n</code></pre>\n<p>看，就是寫兩次而已，這真的很糟糕</p>\n<p>因為我們很可能會忘記寫某一個<code>join</code>，然後沒看到，或是當下看不出來，最後 trace bug 還看到<code>terminate</code>然後想----我為什麼會呼叫 terminate?恩，因為你沒有呼叫，最後憤怒的找到 thread 函式庫</p>\n<p>第二種辦法是 RAII</p>\n<pre><code class=\"language-c++\">class Thread_guard {\n    std::thread t;\npublic:\n    explicit Thread_guard(std::thread&#x26; t_)\n        : t{t_}\n    {}\n    ~Thread_guard() {\n        if (t.joinable()) { t.join(); }\n    }\n}\n</code></pre>\n<p>現在我們把<code>thread</code>放進去就好了，值得一提的是，這種物件最好移除複製建構子和複製指派運算子</p>\n<pre><code class=\"language-c++\">Thread_guard(Thread_guard const&#x26;) = delete;\nThread_guard&#x26; operator=(Thread_guard const&#x26;) = delete;\n</code></pre>\n<p>因為兩種操作對這個物件而言都異常危險，我們將無法預測會發生什麼事</p>\n<p>宣告為 delete 之後，試圖做上述操作都會直接被編譯器擋下</p>\n<p>用法非常明確</p>\n<pre><code class=\"language-c++\">std::thread t{func}\nThread_guard tg{t}\n\n// do something ...\n</code></pre>\n<p>這樣一來，只要離開資源，tg 的解構式被啟動，就會決定怎麼處理 thread 物件(這仰賴 c++對解構的保證)</p>\n<p>最後，注意<code>cout</code>其實不能那樣用，你可以試試使用迴圈讓執行緒印更多東西，然後你會發現文字會不按順序的亂印，這是正常的，因為它們交錯的使用<code>cout</code>，而沒有一個資源管理的方式</p>\n<p>最簡單的方式就是上鎖，當然也有對這類行為不太介意的程式，例如共享的資源是唯獨的</p>","frontmatter":{"title":"C++ thread 基礎"}}},"pageContext":{"slug":"/blog/cs/cpp-thread/"}}}