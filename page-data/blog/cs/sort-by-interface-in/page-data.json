{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/sort-by-interface-in/","result":{"data":{"markdownRemark":{"html":"<p>Sort is an operation very often to use.\nAlthough a <code>quick-sort</code> isn't too long. We still don't want to create it again and again.\nIt also don't have the value to copy it.</p>\n<p>Good news is standard package <code>sort</code> provide a lots of sort function.\nUnlike most language do, it's no association with type or data structure.\nFunction <code>sort.Sort</code> do not have any expected to it's target.\nIt use <code>sort.Interface</code> to detect how to work.</p>\n<pre><code class=\"language-golang\">package sort\n\ntype Interface {\n    Len() int\n    Less(i, j int) bool // i, j is index of element\n    Swap(i, j int)\n}\n</code></pre>\n<p>Let's start it.</p>\n<script src=\"https://gist.github.com/dannypsnl/1f4a59834aae245d3a9bc1613a26650b.js\"></script>\n<p>Let me explain it.</p>\n<ul>\n<li><code>Len</code> mean size of the target</li>\n<li><code>Less</code> provide a common way to compare two elements in target</li>\n<li><code>Swap</code> provide a common way to swap two elements</li>\n</ul>\n<p>It just a concept. So let's dig into golang implementation.</p>\n<pre><code class=\"language-golang\">package sort\n// 上省５００行...\nfunc Sort(data Interface) {\n    n := data.Len()\n    quickSort(data, 0, n, maxDepth(n))\n}\n// 下略５００行...\n// ps. No real 500\n</code></pre>\n<p><code>Sort</code> is easier than my imagine. Awesome!</p>\n<p>From this, we know have to go into <code>quicksort</code>.</p>\n<pre><code class=\"language-golang\">package sort\n// 上省５００行...\nfunc quickSort(data Interface, a, b, maxDepth int) {\n    for b-a > 12 { // Use ShellSort for slices &#x3C;= 12 elements\n        if maxDepth == 0 {\n            heapSort(data, a, b)\n            return\n        }\n        maxDepth--\n        mlo, mhi := doPivot(data, a, b)\n        if mlo-a &#x3C; b-mhi {\n            quickSort(data, a, mlo, maxDepth)\n            a = mhi\n        } else {\n            quickSort(data, mhi, b, maxDepth)\n            b = mlo\n        }\n    }\n    if b-a > 1 {\n        // Do ShellSort pass with gap 6\n        // It could be written in this simplified form cause b-a &#x3C;= 12\n        for i := a + 6; i &#x3C; b; i++ {\n            if data.Less(i, i-6) {\n                data.Swap(i, i-6)\n            }\n        }\n        insertionSort(data, a, b)\n    }\n}\n// 下略５００行...\n</code></pre>\n<p><code>maxDepth</code> detect the size should use heap sort or not.</p>\n<p>The more you should go to read algorithm. But you can get the unusual theory from Go's design of <code>sort</code> package.</p>\n<p>Thank for read.</p>\n<h3>References:</h3>\n<h4><a href=\"http://www.gopl.io/\">The Go programming language</a></h4>\n<ul>\n<li>Author: Alan A. A. Donovan &#x26; Brian W. Kernighan</li>\n<li>ISBN: 978-986-476-133-3</li>\n</ul>","frontmatter":{"title":"Sort by interface in Go"}}},"pageContext":{"slug":"/blog/cs/sort-by-interface-in/"}}}