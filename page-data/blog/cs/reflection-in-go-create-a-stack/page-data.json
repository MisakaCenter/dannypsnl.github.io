{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/reflection-in-go-create-a-stack/","result":{"data":{"markdownRemark":{"html":"<p>Do you know what can Go's package <code>reflect</code> do?</p>\n<p>Whatever you had use it or not. Understanding it is not a bad thing.</p>\n<p>A well known thing is Go don't have generic, I'm not going to tell you we have generic, I'm going to tell you some basic trick to have the result like generic.</p>\n<p>Real world example: <a href=\"https://github.com/elz-lang/elz-go-backup/tree/master/collection/stack/stack.go\">elz-lang/collection/stack</a></p>\n<p>Elz is a language I'm developing, but that's not the point. Point is this collection/stack using the trick I'm going to talk about.</p>\n<p>Take a look on the type <code>Stack</code></p>\n<pre><code class=\"language-go\">type Stack struct {\n    stack  []interface{}\n    limitT *reflect.Type\n}\n</code></pre>\n<p><code>limitT</code> is a <code>*reflect.Type</code>, the reason that it's a pointer to <code>reflect.Type</code> rather than <code>reflect.Type</code> is because of we may do not spec it.</p>\n<p>We add the <code>Stack&#x3C;T></code> by invoke <code>WithT</code>.</p>\n<pre><code class=\"language-go\">func (s *Stack) WithT(v interface{}) *Stack {\n    t := reflect.TypeOf(v).Elem()\n    s.limitT = &#x26;t\n    return s\n}\n</code></pre>\n<p>Why is <code>reflect.TypeOf(v).Elem()</code>? Because we can't really get an instance that type is an interface! Instead of that, we can get a type is pointer to an interface!</p>\n<p>We have a common idiom is using <code>(*SomeInterface)(nil)</code> to get pointer to interface instance.</p>\n<p>Now we know that user code can be</p>\n<pre><code class=\"language-go\">type AST interface {\n    Gen() llvm.Value\n}\n\n// main\ns := stack.New().WithT((*AST)(nil))\n</code></pre>\n<p>After we do that, user can't push a value do not implement <code>AST</code>.</p>\n<p>So, how we do that? We do a check at <code>Push</code></p>\n<pre><code class=\"language-go\">func (s *Stack) Push(element interface{}) {\n    if s.limitT != nil {\n        if !reflect.TypeOf(element).Implements(*s.limitT) {\n            panic(fmt.Sprintf(\"element must implement type: %s\", *s.limitT))\n        }\n    }\n    s.stack = append(s.stack, element)\n}\n</code></pre>\n<p>If <code>limitT</code> is not <code>nil</code>, means we do not limit the type, just keep going on.</p>\n<p>But if we limit the type, we check that <code>element</code> implements <code>limitT</code> or not.</p>\n<p>If not, we panic the process.</p>\n<p>Now we have a stack can promise type safe at runtime.</p>","frontmatter":{"title":"Reflection in Go: create a stack[T]"}}},"pageContext":{"slug":"/blog/cs/reflection-in-go-create-a-stack/"}}}