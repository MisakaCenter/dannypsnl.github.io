{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/lexer/","result":{"data":{"markdownRemark":{"html":"<p>因為 Elz 實在是一個遠超我一開始的預想的語言(最開始只是想了解編譯器，乾脆就開始設計新語言了)</p>\n<p>打造花了我很多心思，Elz 採用先從原始碼中取得詞素，再分析詞素的設計</p>\n<p>這樣一來兩邊都可以降低實作的複雜度</p>\n<p>分成<code>lexer</code>與<code>parser</code>兩大主軸工作之後，考慮到效能，我沒有採用 lex 這種吸引人的作法(其實一開始是有試過，最重要的問題是我覺得學那個好麻煩 XD)</p>\n<p>而是手刻這個部分，其中最重要的設計就是利用<code>Golang</code>的共時技巧，讓<code>parser</code>可以不用等待<code>lexer</code>的完成</p>\n<p>這個技術的完成第一是寫出一個函數，建立一個<code>lexer</code>實體，接著用<code>goroutine</code>啟動<code>(*lexer) run()</code>這個函數，最後這個函數回傳這個<code>lexer</code>實體</p>\n<p>run 之中放著 State Function 迴圈</p>\n<p>什麼是 State Function? 它就是一個型別函數，不過它所指的函數回傳自己這個型別以作為狀態變遷的依據</p>\n<p><code>stateFn</code>定義如下:</p>\n<pre><code class=\"language-golang\">type stateFn func(*Lexer) stateFn\n</code></pre>\n<p>什麼叫狀態變遷? 這樣有什麼好處?</p>\n<p>讓我們回顧 Lexer 的原理，它接收一個字元串流，根據讀到的字元進行不同的操作，以得到詞素串流</p>\n<p>所以不同的字元就是那個狀態啦!</p>\n<p>而傳統的做法都像下面那樣</p>\n<pre><code class=\"language-c\">void LexAll(int state) {\n  switch(state) {\n  case number:\n    LexNumber();\n  case alphabra:\n    LexIdentifier();\n  // ...\n  }\n}\n</code></pre>\n<p>重複不斷的程式碼，而且我們一直在呼叫函數</p>\n<p>那何不傳回我們想執行的下一個函式?</p>\n<p>這就是 State Function 所想要表達的意思</p>\n<pre><code class=\"language-golang\">func lexWhiteSpace(l *Lexer) stateFn {\n    for r := l.next(); isSpace(r) || r=='\\n'; l.next() {\n        r = l.peek()\n    }\n    l.backup() // break mount's rune is not a space\n    l.ignore() // because no emit, we need ignore will mount's pos runes\n\n    switch r := l.next(); {\n    case r == EOF:\n        l.emit(ItemEOF)\n        return nil\n        // ...\n    case r == '=':\n        return lexEqualOp // =, ==\n    case r == ':':\n        l.emit(ItemColon)\n        return lexWhiteSpace\n    case r == '\"' || r == '`' || r == '\\'':\n        return lexString // \"string literal\", `string literal`\n    case '0' &#x3C;= r &#x26;&#x26; r &#x3C;= '9':\n        return lexNumber // 12323, 2.344\n    case isAlphaNumeric(r):\n        return lexIdentifiers // car, car_build\n    default:\n        panic(fmt.Sprintf(\"Don't know how to do with: %q\", r))\n    }\n}\n</code></pre>\n<p>這是作為初始狀態的狀態函數內部實作(省略沒有辦法幫助你理解它的部分)</p>\n<p>再看<code>lexNumber</code></p>\n<pre><code class=\"language-golang\">func lexNumber(l *Lexer) stateFn {\n    firstDot := true\n    for r := l.next(); ( '0' &#x3C;= r &#x26;&#x26; r &#x3C;= '9' ) || r == '.'; r = l.next() {\n        if r == '.' {\n            if firstDot {\n                firstDot = false\n            } else {\n                break\n            }\n        }\n    }\n    l.backup()\n\n    l.emit(ItemNumber)\n    return lexWhiteSpace\n}\n</code></pre>\n<p>發現了嗎? 只要回傳初始狀態函數</p>\n<p>由於我們不斷執行下一個狀態函數，所以我們就回到初始狀態了，而且不需要初始狀態碼跟初始狀態用的函數兩個東西來完成它</p>\n<p>這時我們就要回到 run 的實現了</p>\n<p>看看它有多麼的簡單</p>\n<pre><code class=\"language-golang\">func (l *Lexer) run() {\n    for l.state = lexWhiteSpace; l.state != nil; {\n        l.state = l.state(l)\n    }\n    close(l.items)\n}\n得到一個狀態函數參考，然後執行狀態函數，就這麼簡單\n\n// l.state是一個stateFn\n</code></pre>\n<p>我改用Ｃ＋＋實作了，不過這篇的技術還是很有趣，所以就留下來吧！</p>\n<p>ps. 2017/12/29. 我現在還是用 Go，只是先用 antlr 產生 parser(開發速度)</p>","frontmatter":{"title":"lexer 原理解釋"}}},"pageContext":{"slug":"/blog/cs/lexer/"}}}