{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/nix/","result":{"data":{"markdownRemark":{"html":"<p>This article is created as a record of the feedback of the usage of nix, also stand for learning how to use nix in daily developing life. Remember I would not dig into the implementation or model concept inside of nix but all about how to use it to improve the developing environment.</p>\n<h3>Install</h3>\n<p>To install nix all you have to do is running: <code>sh &#x3C;(curl https://nixos.org/nix/install) --no-daemon</code> and follow the content, provided by the script after the script installed process down, on Linux or macOS.</p>\n<p>To avoid outdated information, here is the <a href=\"https://nixos.org/nix/manual/#sect-single-user-installation\">single-user installation</a>(which you do above), and the <a href=\"https://nixos.org/nix/manual/#sect-multi-user-installation\">multi-user installation</a>.</p>\n<h3>Introduction</h3>\n<p>After installation, you would get several different commands for different purposes. I would introduce them one by one(only for those I'm using).</p>\n<h4>nix-env</h4>\n<p><code>nix-env</code> is like <code>brew</code> for MacOS, <code>apt-get</code> for Ubuntu, <code>yum</code> for CentOS, but for all platform with nix. This command is the first one command would help immediately. You can do: <code>nix-env -i go</code> or <code>nix-env --install go</code>, after that let's check the binary <code>go</code> by <code>which go</code>, is located at <code>$HOME/.nix-profile/bin/go</code>. You can also use different channel(package source) for self-deployed packages or any other is not provided by nix channel.</p>\n<p>Use <code>nix-env --help</code> to get more information</p>\n<h4>nix-shell</h4>\n<p><code>nix-shell</code> would read <code>shell.nix</code> or fallback to read <code>default.nix</code> these config files. To understand what we do in it we need an example:</p>\n<pre><code class=\"language-nix\">let\n  pkgs = import &#x3C;nixpkgs> { };\n  inherit (pkgs) mkShell;\n  inherit (pkgs) haskellPackages;\n  inherit (haskellPackages) cabal-install;\n  inherit (haskellPackages) stylish-haskell;\n\n  ghc = haskellPackages.ghcWithPackages (pkgs: with pkgs; [base mtl]);\nin\nmkShell {\n  buildInputs = [\n    ghc\n    cabal-install\n    stylish-haskell\n  ];\n}\n</code></pre>\n<p><code>mkShell</code> would return a shell by its argument set: <code>{}</code>, at here we can take a look at <code>stylish-haskell</code> this Haskell formatter, in <code>nix-shell</code> environment type <code>which stylish-haskell</code> would get <code>/nix/store/qqj9ldclapfbxhnvb357mjy5d5rjg6ip-stylish-haskell-0.9.2.2/bin/stylish-haskell</code>, and if you quit the environment should won't have the binary.</p>\n<h4>nix-build</h4>\n<p>Now, we already introduce the global level installer and project level installer. We have to go into how to create your own package.</p>\n<p><code>nix-build</code> would read <code>default.nix</code> to use its value as your package. Let's take a look at what it means.</p>\n<pre><code class=\"language-nix\">let\n  pkgs = import &#x3C;nixpkgs> { };\n\n  dependencies = import ./deps.nix;\nin\n  pkgs.haskellPackages.callPackage ./little-scheme.nix { dependencies=dependencies; }\n</code></pre>\n<p>Ignore <code>deps.nix</code>, that's a list has all Haskell dependencies I used.</p>\n<p><code>pkgs.haskellPackages.callPackage</code> creates a haskell package via it's argument. Let's dig into what <code>little-scheme.nix</code> do:</p>\n<pre><code class=\"language-nix\">{ mkDerivation, base, mtl, dependencies, stdenv }:\nmkDerivation {\n  pname = \"little-scheme\";\n  version = \"0.1.0\";\n  src = stdenv.lib.sourceFilesBySuffices ./. [\".hs\" \".cabal\" \"LICENSE\"];\n  isLibrary = false;\n  isExecutable = true;\n  executableHaskellDepends = [ base mtl ] ++ dependencies;\n  license = stdenv.lib.licenses.mit;\n}\n</code></pre>\n<p><code>src</code> be set to <code>stdenv.lib.sourceFilesBySuffices ./. [\".hs\" \".cabal\" \"LICENSE\"]</code>, this line means only <code>.hs</code>, <code>.cabal</code> and <code>LICENSE</code> would lead a new build.</p>\n<p><code>executableHaskellDepends</code> would take a list of Haskell libraries.</p>\n<p><code>{}: expression</code> is a function. <code>{}</code> use pattern matching to extract the value from input set. <code>a: c</code> is take <code>a</code> return <code>c</code>, <code>a: b: c</code> is take <code>a</code> return <code>b: c</code>, consider to read <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">lambda calculus</a> to understand the function in nix.</p>\n<h3>Advanced use case</h3>\n<h4>direnv</h4>\n<p><code>direnv</code> is a powerful shell environment extension, it loads or unloads an environment depending on the current directory. To install it we can execute <code>nix-env --install direnv</code>, then add <code>eval \"$(direnv hook zsh)\"</code> at the end of <code>$HOME/.zshrc</code>(<a href=\"https://github.com/direnv/direnv/blob/master/docs/hook.md\">for others shells</a>).</p>\n<p><code>direnv</code> supports using nix as environment configuration, you can put <code>use_nix</code> in the <code>$dir/.envrc</code>, and it would watch <code>$dir/shell.nix</code> and <code>$dir/default.nix</code> to update the environment. However, the current version <code>use_nix</code> has cache missing issue, so you can just copy whole content from <a href=\"https://github.com/kalbasit/nur-packages/blob/master/pkgs/nixify/envrc\">https://github.com/kalbasit/nur-packages/blob/master/pkgs/nixify/envrc</a>, and put <code>use_nix -s shell.nix</code> in the <code>$dir/.envrc</code>.</p>\n<p>p.s. A minor issue is <code>direnv</code> do not work with <code>alias</code>, so probably still have to use <code>$HOME/.zshrc</code> to manage them.</p>","frontmatter":{"title":"nix report"}}},"pageContext":{"slug":"/blog/cs/nix/"}}}