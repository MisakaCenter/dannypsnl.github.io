{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/error-is/","result":{"data":{"markdownRemark":{"html":"<p>I think most of Gopher had read <a href=\"https://blog.golang.org/error-handling-and-go\">error-handling-and-go</a></p>\n<p>Has anyone had watched <a href=\"https://www.youtube.com/watch?v=1B71SL6Y0kA\">Go Lift</a>?</p>\n<p>Let's getting start from <strong>Go Lift</strong>!</p>\n<p>The point of <strong>Go Lift</strong> is: Error is Value.</p>\n<p>Of course, we know this fact. But do you really understand what that means?</p>\n<p>In <strong>Go Lift</strong>, <strong>John Cinnamond</strong> mentions a trick about wrapping the error by command executor.</p>\n<p>For example, we create a connection to <code>server:6666</code> by TCP.</p>\n<pre><code class=\"language-go\">conn := net.Dial(\"tcp\", \"server:6666\")\n</code></pre>\n<p>Can we? Ah..., No!</p>\n<p>Correct code is</p>\n<pre><code class=\"language-go\">conn, err := net.Dial(\"tcp\", \"server:6666\")\nif err != nil {\n    panic(err)\n}\n</code></pre>\n<p>Then we writing something to the connection.</p>\n<pre><code class=\"language-go\">nBtye := conn.Write([]byte{`command`})\n</code></pre>\n<p>We want that, but the real code is</p>\n<pre><code class=\"language-go\">nBtye, err := conn.Write([]byte{`command`})\nif err != nil {\n    panic(err)\n}\n// using nByte\n</code></pre>\n<p>Next, we read something from <code>server:6666</code>, so we create a reader.</p>\n<pre><code class=\"language-go\">reader := bufio.NewReader(conn)\nresponse := reader.ReadString('\\n')\n</code></pre>\n<p>No! We have to handle the error.</p>\n<pre><code class=\"language-go\">response, err := reader.ReadString('\\n')\nif err != nil {\n    panic(err)\n}\n// using response\n</code></pre>\n<p>But the thing hasn't ended yet if we have to rewrite the command if response tells us the command fail?</p>\n<p>If we are working for a server, we can't just panic?</p>\n<p>So <strong>Go Lift</strong> has a solution:</p>\n<pre><code class=\"language-go\">func newSafeConn(network, host string) *safeConn {\n    conn, err := net.Dail(network, host)\n    return &#x26;safeConn{\n        err: err,\n        conn: conn, // It's fine even conn is nil\n    }\n}\n\ntype safeConn struct {\n    err error\n\n    conn net.Conn\n}\n\nfunc (conn *safeConn) Write(bs []byte) {\n    if conn.err != nil {\n    // if contains error, do nothing\n        return\n    }\n    _, err := conn.Write(bs)\n    conn.err = err // update error\n}\n\nfunc (conn *safeConn) ReadString(delim byte) string {\n    if conn.err != nil {\n        return \"\"\n    }\n    reader := bufio.NewReader(conn.conn)\n    response, err := reader.ReadString(\"\\n\")\n    conn.err = err\n    return response\n}\n</code></pre>\n<p>Then usage will become</p>\n<pre><code class=\"language-go\">conn := newSafeConn(\"tcp\", \"server:6666\")\nconn.Write([]byte{`command`})\nresponse := conn.ReadString('\\n')\n\nif conn.err != nil {\n    panic(conn.err)\n}\n// else, do following logic\n</code></pre>\n<p>But can we do much more than this?</p>\n<p>Yes! We can have an error wrapper for executing the task.</p>\n<pre><code class=\"language-go\">type ErrorWrapper struct {\n    err error\n}\n\nfunc (wrapper *ErrorWrapper) Then(task func() error) *ErrorWrapper {\n    if wrapper.err == nil {\n        wrapper.err = task()\n    }\n    return wrapper\n}\n</code></pre>\n<p>Then you can put anything you want into it.</p>\n<pre><code class=\"language-go\">w := &#x26;ErrorWrapper{err: nil}\nvar conn net.Conn\nw.Then(func() error {\n    conn, err := net.Dial(\"tcp\", \"server:6666\")\n    return err\n}).Then(func() error {\n    _, err := conn.Write([]byte{`command`})\n})\n</code></pre>\n<p>Wait! But we need to send the connection to next task without an outer scope variable. But how to?</p>\n<p>Now let's get into <code>reflect</code> magic.</p>\n<pre><code class=\"language-go\">type ErrorWrapper struct {\n    err         error\n    prevReturns []reflect.Value\n}\n\nfunc NewErrorWrapper(vs ...interface{}) *ErrorWrapper {\n    args := make([]reflect.Value, 0)\n    for _, v := range vs {\n        args = append(args, reflect.ValueOf(v))\n    }\n    return &#x26;ErrorWrapper{\n        err:         nil,\n        prevReturns: args,\n    }\n}\n\nfunc (w *ErrorWrapper) Then(task interface{}) *ErrorWrapper {\n    rTask := reflect.TypeOf(task)\n    if rTask.NumOut() &#x3C; 1 {\n        panic(\"at least return error at the end\")\n    }\n    if w.err == nil {\n        lenOfReturn := rTask.NumOut()\n        vTask := reflect.ValueOf(task)\n        res := vTask.Call(w.prevReturns)\n        if res[lenOfReturn-1].Interface() != nil {\n            w.err = res[lenOfReturn-1].Interface().(error)\n        }\n        w.prevReturns = res[:lenOfReturn-1]\n    }\n    return w\n}\n\nfunc (w *ErrorWrapper) Final(catch func(error)) {\n    if w.err != nil {\n        catch(w.err)\n    }\n}\n</code></pre>\n<p>Now, we coding like</p>\n<pre><code class=\"language-go\">w := NewErrorWrapper(\"tcp\", \"server:6666\")\n\nw.Then(func(network, host string) (net.Conn, error) {\n    conn, err := net.Dail(network, host)\n    return conn, err\n}).Then(func(conn net.Conn) error {\n    _, err := conn.Write([]byte{`command`})\n    return err\n}).Final(func(e error) {\n    panic(e)\n})\n</code></pre>","frontmatter":{"title":"Error is Value"}}},"pageContext":{"slug":"/blog/cs/error-is/"}}}