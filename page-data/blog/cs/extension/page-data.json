{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/extension/","result":{"data":{"markdownRemark":{"html":"<p>好吧，上一篇說了這麼多，其實幾乎就只是把屬性定義在類別外罷了，沒什麼啊</p>\n<p>這樣並沒有比<code>class</code>強到哪裡</p>\n<p>所以，讓我們來看看<code>extension hacks</code>吧！</p>\n<h2>hack 1:</h2>\n<blockquote>\n<p>extension from a temporary protocol</p>\n</blockquote>\n<pre><code class=\"language-swift\">protocol MenuItem {}\nextension label : MenuItem {}\nextension button : MenuItem {}\n\nvar list = [MenuItem]()\nlist.append(label(\"Hello\"))\nlist.append(button(\"Click me\", event))\n</code></pre>\n<p>哇，這下我們可以用<code>List&#x3C;MenuItem></code>來存放我們所想要存放的型別了，只要將你想要存放的型別<code>extension</code>一下<code>MenuItem</code>這個協定，就是這麼簡單</p>\n<p>注意這個機制有幾個問題，第一是如果你想要呼叫某個屬於 label 的方法，你將會得到沒有此方法的編譯期錯誤</p>\n<p>那，有辦法解決嗎？</p>\n<p>有！首先我們要知道為什麼會這樣，如果你曾經在<code>shell</code>中嘗試過印出<code>type(of: xxx)</code></p>\n<p>那麼你一定知道型別後面都接有一個位元組，這個位元組，其實就是實際上型別在執行期的樣子啦！因此在執行期中，為了確保最大的安全度，編譯器常用最小介面原則，選擇概念最寬廣的那個型別</p>\n<p>那麼編譯器要怎麼知道你是要呼叫子型別的方法還是父型別的呢？</p>\n<p>在 C++我們可以用<code>-></code>運算子以及指標，確保我們直接存取實體，而且我們不需要聲明子型別是什麼，因為編譯器有在記</p>\n<p>不過產生的問題就是，有時候你並不知道到底有沒有這個方法(當然，新的 IDE 與工具們提供了這些，但是我們常常還是編譯下去之後才知道)，進而需要搜尋你用了哪個子型別</p>\n<p>而在 Swift，我們用<code>(instance as! Type).method()</code>使用子型別的方法，缺點是那個括號跟不甚明瞭的語意，而且我們為了確保安全，還要多做一個\n<code>if instacne is Type</code>的檢查</p>\n<p>回到<code>Swift</code></p>\n<p>第一種作法是直接在<code>MenuItem</code>上定義一個方法作為統一的介面，任何型別擴展<code>MenuItem</code>時，就實作該方法</p>\n<p>第二種作法是我們將<code>MenuItem</code>轉換成原本的型別</p>\n<p>這種作法有個小問題：</p>\n<p>問題在於，我們知道<code>label</code>是一種<code>MenuItem</code>，但是你怎麼知道，某個<code>MenuItem</code>是<code>label</code>?</p>\n<p>所以我們需要對它進行危險的轉換</p>\n<pre><code class=\"language-swift\">MenuItem() as! label // as! 意思是將左邊的值當成右邊的型別來使用，而且這是危險的\n</code></pre>\n<blockquote>\n<p>ps. 這只是示意，不能運作</p>\n</blockquote>\n<p>而這對工作上非常不合用，也很難凸顯我們想要做什麼</p>\n<p>所以我寫了一個轉換函式</p>\n<pre><code class=\"language-swift\">func convert&#x3C;F, T>(from: F, to: T) -> T {\n    if from is T {\n        return from as! T\n    } else {\n        return to\n    }\n}\n</code></pre>\n<blockquote>\n<p>ps. 請不要真的用這個函數做事，這只是為了先避開複雜議題(例外處理)才這樣寫的</p>\n</blockquote>\n<p>於是我們可以用</p>\n<pre><code class=\"language-swift\">let res = convert(from: MenuItem(), to: label())\n</code></pre>\n<p>取得一個轉換結果，在這裡因為我們失敗時<code>(from不是一種T)</code>就回傳<code>to</code></p>\n<p>我們沒辦法知道是成功抑或失敗，因此我們應該對此有所區別</p>\n<pre><code class=\"language-swift\">func downCast&#x3C;F, T>(from: F, to: T) -> T? {\n    if from is T {\n        return from as? T\n    } else {\n       return nil\n    }\n}\n</code></pre>\n<p>這是第二版的轉換函數，我用<code>downCast</code>是要說明我們在做危險的向下轉型(上面的<code>convert</code>則是說明它是通用的轉換)</p>\n<p>同時這次失敗將回傳<code>nil</code></p>\n<p>因此使用上使用者將需要多負擔一個<code>!</code>來解包</p>\n<pre><code class=\"language-swift\">let res = downCast(from: num, to: Double())\nprint(res!)\n</code></pre>\n<p>藉由<code>nil</code>，這個版本保證我們通常能知道有沒有轉型失敗(不過回傳<code>nil</code>雖然侵入性小，卻也把檢查責任丟給客戶端，而且不能應付本來就是<code>nil</code>的實體)</p>\n<p>同時，我認為大部分時候，我們不應該用第一種作法，除非你真的很確定你只是需要這個方法</p>\n<p>為什麼說第二種作法比較好呢？因為我們經常性面對的問題通常與 App 開發有關</p>\n<p>因此需要確切型別的機會比較高，而且第二種作法的侵入性低，未來要對介面進行改變也比較容易，同時 Swift 可還有傳統的介面繼承啊！如果真的需要某個方法提供行為，應該用繼承的方式，直接定義在 class 宣告上</p>\n<p>在呼叫轉換函數時，可以看到</p>\n<pre><code class=\"language-swift\">convert(from: xxx, to: label())\n</code></pre>\n<p><code>to</code>接收一個實體，我稱之為<code>Target Type instance</code>，只要忽略它的括號，我們就能取得還不錯的可讀性，可喜可賀可喜可賀！</p>\n<h2>hack 2:</h2>\n<blockquote>\n<p>default subset of protocol</p>\n</blockquote>\n<p>如果我們想要做一個新的協定，同時不希望使用者還要浪費時間定義哪些可以符合協定</p>\n<p>我們可以利用<code>extension</code></p>\n<pre><code class=\"language-swift\">protocol Format {}\nextension Double : Format {}\nextension Int : Format {}\n</code></pre>\n<p>這個 hack 跟上一個 hack 有 87%像，讓他們有差別的地方在於所求不一樣</p>\n<p>hack 2 專注於提供一組符合協定的預設型別集合</p>\n<p>相較於 hack 2，hack 1 只在乎如何讓自訂的型別放進一個泛型容器之中，以及我們怎麼安全的拿出來</p>\n<p>hack 2 的重點是讓某個你提供的<code>protocol</code>具有已經具現化的可使用型別集合</p>\n<p>所以我這裡舉了<code>Format</code>作為例子，假設你提供了一個<code>Format protocol</code>給你的<code>Logger</code>函式庫，<code>Format protocol</code>要求使用者實作<code>format</code>方法，那麼提供一些實作給常用的型別讓人瞻仰你的厲害，不是啦！是讓別人能夠享受某些成果，那麼這個程式庫方能永恆啊！</p>","frontmatter":{"title":"Extension hack"}}},"pageContext":{"slug":"/blog/cs/extension/"}}}