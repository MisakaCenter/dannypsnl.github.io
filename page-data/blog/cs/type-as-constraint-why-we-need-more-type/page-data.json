{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/type-as-constraint-why-we-need-more-type/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://dannypsnl.github.io"}},"markdownRemark":{"html":"<p>For me, programming was about how to map my mind to the world; from this view, it probably shows why I tend to use statically typed language. A strong model could ensure more people won't misunderstand our purpose. This article was going to show some strategy to promise the thing works in our mind won't be broken by others accident.</p>\n<p>Now consider a situation, we had a list of something and we just sort it and we want to do binary-search with it. A subtle problem was we were hard to ensure the list was sorted. In the language such as Python or C, we had to promise this by ourselves. So we insert <code class=\"language-text\">assert(sorted(list))</code> into our program like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">binary_search</span><span class=\"token punctuation\">(</span>lst<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">assert</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>lst<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># ...</span></code></pre></div>\n<p>p.s. <a href=\"https://www.programiz.com/python-programming/assert-statement\">More assertion in Python</a>, I'm not a Python master. I have to say.</p>\n<p>And then we feel the program became slower. Because we were so smart, we distinguish debug and release environment, there were no assertions in release mode. Now everything runs good, right? Well, if you wrote some programs with verified data, that's ok. But what if the <code class=\"language-text\">lst</code> came from the user input? It probably would break, or let's be honest, it would break. So remove checking from there shouldn't happen. But many languages cannot ensure it, we have to take responsibility.</p>\n<p>With wrapping, we can make it a little bit better. We can do this:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">Sort</span><span class=\"token punctuation\">(</span>lst <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> SortedList <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// sorting</span>\n\t<span class=\"token keyword\">return</span> SortedList<span class=\"token punctuation\">{</span>lst<span class=\"token punctuation\">:</span> lst<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> SortedList <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\tlst <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">BinarySearch</span><span class=\"token punctuation\">(</span>lst SortedList<span class=\"token punctuation\">)</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// you know, just ignore how we get the element</span>\n\t<span class=\"token keyword\">return</span> element\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tlst <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span>\n\tsortedLst <span class=\"token operator\">:=</span> <span class=\"token function\">Sort</span><span class=\"token punctuation\">(</span>lst<span class=\"token punctuation\">)</span>\n\t<span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> <span class=\"token function\">BinarySearch</span><span class=\"token punctuation\">(</span>sortedLst<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>But this is a weak promise, anyone can just use <code class=\"language-text\">SortedList{lst: lst}</code> to break it, but better than no promise. But already easier to find out in code review.</p>\n<p>The problem was this is not just easy to break, but it also didn't promise enough information for us. What if we modify the list before we use <code class=\"language-text\">BinarySearch</code>? This promise required some human work to check it. Now we want a more improved version. A promise that cannot be violated and doesn't need human work to check the mechanism. As usual, I would use pseudo-code(to get more information, ref to <a href=\"https://dannypsnl.github.io/docs/cs/infinite-type/\">my another article</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sort[T: comparable](list: List[T]): Output\nwhere\n  Output = List[T] // type alias\n  Output &lt;: sorted // now we know the result type was a subtype of `sorted`\n{\n  // sorting\n}\n\nbinary_search[T: comparable](list: List[T] &lt;: sorted): T {\n  // do something and get the answer\n  return element;\n}</code></pre></div>\n<p>and then we can use them like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sorted_list: List[int] = sort(list);\n_: int = binary_search(sorted_list); // `_` explicitly ignore value</code></pre></div>\n<p>The most important thing is when we do operations that do not fit trait <code class=\"language-text\">sorted</code> the program work as usual but the compiler won't think the value was <code class=\"language-text\">sorted</code> anymore, e.g.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sorted_list: List[int] = sort(list);\nsorted_list.push(3); // add element\n_: int = binary_search(sorted_list);</code></pre></div>\n<p>Now it won't get compiled, because the type mismatching, we can do <code class=\"language-text\">push</code> on <code class=\"language-text\">List[int]</code>, but after that <code class=\"language-text\">sorted_list</code> won't belong to <code class=\"language-text\">sorted</code> trait anymore. Do you probably think why not make another type? Because although we, of course, can do that, it would be bad modeling in another case, when we just sort a list and later keep doing something on it and don't care about it's sorted or not til next sort, create another type would let we must keep converting type manually, which violate our spirit! Now back, <code class=\"language-text\">sorted</code> trait modeled the situation very well, we only have to give tag, the compiler checks the rest. We still have checking, we have to ensure the part need to do <code class=\"language-text\">binary_search</code> get <code class=\"language-text\">List[T] &lt;: sorted</code>, but this is better than adding assertion everywhere. I hope you have a nice day and thanks for the read.</p>","frontmatter":{"title":"Type as Constraint: Why we need more type?","categories":["cs"],"tags":["plt","language"]}}},"pageContext":{"slug":"/blog/cs/type-as-constraint-why-we-need-more-type/"}}}