{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/cs/xdp-some/","result":{"data":{"markdownRemark":{"html":"<p>What is XDP? XDP is eXpress Data Path, it's a technology about putting a BPF code virtual machine on the NIC(network interface controller) driver before kernel network stack so that we can filter the packet before kernel, it would make processing speed greater.</p>\n<p>We can do following things on the packet:</p>\n<ul>\n<li><code>XDP_PASS</code>: allow the packet to pass through</li>\n<li><code>XDP_DROP</code>: drop the packet</li>\n<li><code>XDP_TX</code>: bounce the packet back on the same interface</li>\n<li><code>XDP_REDIRECT</code>: redirects the packet to another interface</li>\n</ul>\n<p>Here is an example of counting how many IPv4/6 packets be dropped.</p>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/signal\"\n\n    bpf \"github.com/iovisor/gobpf/bcc\"\n)\n\n// bcc is from iovisor/bcc this project\n/*\n#cgo CFLAGS: -I/usr/include/bcc/compat\n#cgo LDFLAGS: -lbcc\n#include &#x3C;bcc/bpf_common.h>\n#include &#x3C;bcc/libbpf.h>\nvoid perf_reader_free(void *ptr);\n*/\nimport \"C\"\n\nconst source string = `\n#define KBUILD_MODNAME \"foo\"\n#include &#x3C;uapi/linux/bpf.h>\n#include &#x3C;linux/in.h>\n#include &#x3C;linux/if_ether.h>\n#include &#x3C;linux/if_packet.h>\n#include &#x3C;linux/if_vlan.h>\n#include &#x3C;linux/ip.h>\n#include &#x3C;linux/ipv6.h>\nBPF_TABLE(\"array\", int, long, dropcnt, 256);\nstatic inline int parse_ipv4(void *data, u64 nh_off, void *data_end) {\n    struct iphdr *iph = data + nh_off;\n    if ((void*)&#x26;iph[1] > data_end)\n        return 0;\n    return iph->protocol;\n}\nstatic inline int parse_ipv6(void *data, u64 nh_off, void *data_end) {\n    struct ipv6hdr *ip6h = data + nh_off;\n    if ((void*)&#x26;ip6h[1] > data_end)\n        return 0;\n    return ip6h->nexthdr;\n}\nint xdp_prog1(struct xdp_md *ctx) {\n    void* data_end = (void*)(long)ctx->data_end;\n    void* data = (void*)(long)ctx->data;\n    struct ethhdr *eth = data;\n\n    uint64_t nh_off = sizeof(*eth);\n    if (data + nh_off  > data_end)\n        return XDP_DROP;\n    uint16_t h_proto = eth->h_proto;\n    if (h_proto == htons(ETH_P_8021Q) || h_proto == htons(ETH_P_8021AD)) {\n        struct vlan_hdr *vhdr;\n        vhdr = data + nh_off;\n        nh_off += sizeof(struct vlan_hdr);\n        if (data + nh_off > data_end)\n            return XDP_DROP;\n            h_proto = vhdr->h_vlan_encapsulated_proto;\n    }\n    if (h_proto == htons(ETH_P_8021Q) || h_proto == htons(ETH_P_8021AD)) {\n        struct vlan_hdr *vhdr;\n        vhdr = data + nh_off;\n        nh_off += sizeof(struct vlan_hdr);\n        if (data + nh_off > data_end)\n            return XDP_DROP;\n            h_proto = vhdr->h_vlan_encapsulated_proto;\n    }\n    int index;\n    if (h_proto == htons(ETH_P_IP))\n        index = parse_ipv4(data, nh_off, data_end);\n    else if (h_proto == htons(ETH_P_IPV6))\n        index = parse_ipv6(data, nh_off, data_end);\n    else\n        index = 0;\n    long *value;\n    value = dropcnt.lookup(&#x26;index);\n    if (value) lock_xadd(value, 1);\n    return XDP_DROP;\n}\n`\n\nfunc usage() {\n    fmt.Printf(\"Usage: %v &#x3C;ifdev>\\n\", os.Args[0])\n    fmt.Printf(\"e.g.: %v eth0\\n\", os.Args[0])\n    os.Exit(1)\n}\n\nfunc main() {\n    if len(os.Args) != 2 {\n        usage()\n    }\n    module := bpf.NewModule(source, []string{\n        \"-w\",\n    })\n    defer module.Close()\n\n    fn, err := module.Load(\"xdp_prog1\", C.BPF_PROG_TYPE_XDP, 1, 65536)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to load xdp prog: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    device := os.Args[1]\n    if err := module.AttachXDP(device, fn); err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to attach xdp prog: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    defer func() {\n        if err := module.RemoveXDP(device); err != nil {\n            fmt.Fprintf(os.Stderr, \"Failed to remove XDP from %s: %v\\n\", device, err)\n        }\n    }()\n\n    fmt.Println(\"Dropping packets, hit CTRL+C to stop\")\n    sig := make(chan os.Signal, 1)\n    signal.Notify(sig, os.Interrupt, os.Kill)\n\n    dropcnt := bpf.NewTable(module.TableId(\"dropcnt\"), module)\n\n    &#x3C;-sig\n\n    fmt.Println(\"\\n{IP protocol-number}: {total dropped pkts}\")\n    for it := dropcnt.Iter(); it.Next(); {\n        key := bpf.GetHostByteOrder().Uint32(it.Key())\n        value := bpf.GetHostByteOrder().Uint64(it.Leaf())\n\n        if value > 0 {\n            fmt.Printf(\"%v: %v pkts\\n\", key, value)\n        }\n    }\n}\n</code></pre>","frontmatter":{"title":"XDP some note"}}},"pageContext":{"slug":"/blog/cs/xdp-some/"}}}